#!/usr/bin/env python3

import sys

from dataclasses import dataclass
from typing import List, Union

# OK so now we have the two file lists (generated by `compare_folders.sh`) which are basically like two small DB's (or perhaps two tables).
# Now we need to write the logic that compares the two lists
#
# What we want to know is:
# 1. Which files exist in the source but not in the dest dir (and vice versa)
# 2. Which files exist in both dirs but have different sizes
#
# I guess that's it
#
# What we need to decide is what is considered the same file
# -> same name is not an option because we might have two different files with the same name
# -> same folder+name might be an option, but we need to assume that the parent dirs have the same name
#
# Another thing I might need to consider is the folder structure affects the behavior:
# 1. What if there are >2 levels of hierarchy (.../4/3/2_parent_folder/1_file) ?
# 2. What if the list of PF's is different?

#------------

@dataclass
class File:
    filename: str
    parent_folder: str
    full_path: str
    size: int
    uuid: str

    def __eq__(self, other) -> bool:
        return self.__key() == other.__key()

    def __key(self):
        return (self.filename, self.size, self.uuid)

    def __hash__(self):
        return hash(self.__key())


class FileIndex:
    def __init__(self, list_fn: str, sep="|"):
        self.list_fn = list_fn
        self.sep = sep

        self._index(self._parse_file_list(list_fn, sep))

    def _parse_file_list(self, list_fn, sep="|"):
        file_list = []
        for line in open(list_fn).readlines():
            parent_folder, filename, size, uuid, full_path = line.split(sep)
            file_list.append(File(filename, parent_folder, full_path.strip(), size, uuid))
        return file_list

    def _index(self, file_list: List[File]):
        self.file_list = file_list

        self.path_to_files = {}
        self.name_to_path = {}
        self.parent_folder_to_file_paths = {}

        # Create various indexes
        for file in self.file_list:

            # By path [assuming unique]
            self.path_to_files[file.full_path] = file

            # By name
            self.name_to_path.setdefault(file.filename, [])
            self.name_to_path[file.filename].append(file.full_path)

            # By parent folder
            self.parent_folder_to_file_paths.setdefault(file.parent_folder, [])
            self.parent_folder_to_file_paths[file.parent_folder].append(file.full_path)

    def by_path(self, file_or_path: Union[File, str]) -> File:
        path = file_or_path
        if isinstance(file_or_path, File):
            path = file_or_path.full_path

        return self.path_to_files[path]

    def by_parent_folder(self, file_or_parent_folder: Union[File, str]) -> List[File]:
        parent_folder = file_or_parent_folder
        if isinstance(file_or_parent_folder, File):
            parent_folder = file_or_parent_folder.parent_folder

        file_paths = self.parent_folder_to_file_paths[parent_folder]
        return [self.by_path(path) for path in file_paths]

    def get_parent_folders(self):
        return set(self.parent_folder_to_file_paths.keys())


#------------

def file_by_fn(file_list, filename):
    return [f for f in file_list if f.filename == filename][0]


def main(source_fn, dest_fn):
    source = FileIndex(source_fn)
    dest = FileIndex(dest_fn)

    # OK now we have the two lists nice & parsed, now comes the ugly part - we need to actually
    # compare them

    # Should I get some more info in the first step of importing the file metadata? (md5sum, exif date)
    # Perhaps let's start with the existing data and then add

    # OK let's start by comparing the parent folders
    source_pfs = source.get_parent_folders()
    dest_pfs = dest.get_parent_folders()

    print(f"source parent folders: {len(source_pfs)}")
    print(f"dest parent folders: {len(dest_pfs)}")

    s_d_pfs = source_pfs - dest_pfs
    d_s_pfs = dest_pfs - source_pfs
    if s_d_pfs:
        print(f"source folders not in dest: {', '.join(s_d_pfs)}")
    if d_s_pfs:
        print(f"dest folders not in source: {', '.join(d_s_pfs)}")

    action_commands = []

    shared_pfs = source_pfs.intersection(dest_pfs)
    print(f"analyzing {len(shared_pfs)} shared folders...")
    for pf in sorted(shared_pfs):
        source_files = source.by_parent_folder(pf)
        dest_files = dest.by_parent_folder(pf)
        print(f"[ {pf} | source: {len(source_files)} files | dest: {len(dest_files)}) files ]")

        # Comparison by Name
        sfsn = set([f.filename for f in source_files])
        dfsn = set([f.filename for f in dest_files])
        s_d_fsn = sfsn - dfsn
        d_s_fsn = dfsn - sfsn
        if s_d_fsn or d_s_fsn:
            print(f"comparison by name | missing in source: {len(d_s_fsn)} | missing in dest: {len(s_d_fsn)}")
            print(" -> missing in source:\n%s" % '\n'.join(d_s_fsn))
            print(" -> missing in dest:\n%s" % '\n'.join(s_d_fsn))

        # Comparison by Size & UUID
        sfs = set(source_files)
        dfs = set(dest_files)
        s_d_fs = sfs - dfs
        d_s_fs = dfs - sfs
        print(f"comparison by size & UUID | missing in source: {len(d_s_fs)} | missing in dest: {len(s_d_fs)}")
        s_d_fs_fns = set([f.filename for f in s_d_fs])
        d_s_fs_fns = set([f.filename for f in d_s_fs])
        same_fn_different_meta = s_d_fs_fns.intersection(d_s_fs_fns)
        print(" -> same filename, different metadata:")
        for fn in same_fn_different_meta:
            sf = file_by_fn(source_files, fn)
            df = file_by_fn(dest_files, fn)
            print(f"{fn} || source // size: {sf.size} | UUID: {sf.uuid} || dest // size: {df.size} | UUID: {df.uuid}")

            # save action command - take the bigger one
            if sf.size > df.size:
                action_commands.append(f'cp "{sf.full_path}" "{df.full_path}"')

        source_only_fs_fn = s_d_fs_fns - d_s_fs_fns - same_fn_different_meta
        dest_only_fs_fn = d_s_fs_fns - s_d_fs_fns - same_fn_different_meta
        if source_only_fs_fn:
            print(f" -> missing in source:\n%s" % '\n'.join(source_only_fs_fn))
            for fn in source_only_fs_fn:
                sf = file_by_fn(source_files, fn)
                df = file_by_fn(dest_files, fn)
                if sf.size > df.size:
                    action_commands.append(f'cp "{sf.full_path}" "{df.full_path}"')
        if dest_only_fs_fn:
            print(f" -> missing in dest:\n%s" % '\n'.join(dest_only_fs_fn))
            for fn in dest_only_fs_fn:
                sf = file_by_fn(source_files, fn)
                df = file_by_fn(dest_files, fn)
                if sf.size > df.size:
                    action_commands.append(f'cp "{sf.full_path}" "{df.full_path}"')

    print("\naction commands:")
    print("\n".join(action_commands))

#------------

if __name__ == "__main__":

    if len(sys.argv) != 3:
        print(f"usage: {sys.argv[0]} <source file list> <dest file list>")
        print()
        print("the script uses two file lists generated by 'compare_folders.sh' to figure out which files are different or missing")
        sys.exit(1)

    source_file_list = sys.argv[1]
    dest_file_list = sys.argv[2]

    main(source_file_list, dest_file_list)


