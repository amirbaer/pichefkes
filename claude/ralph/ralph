#!/usr/bin/env python3
"""
Ralph Loop Runner - Development iteration system for Claude Code.

Runs Claude Code in fresh sessions to complete tasks from a PRD.
State is stored in .ralph/ directory of each project.

Usage:
    ralph run      - Execute PRD tasks
    ralph info     - Show current status
    ralph runs     - List all runs
"""

import argparse
import json
import os
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path

# ═══════════════════════════════════════════════════════════════════
# COLORS
# ═══════════════════════════════════════════════════════════════════


class Colors:
    PINK = "\033[38;5;218m"
    LAVENDER = "\033[38;5;183m"
    MINT = "\033[38;5;158m"
    PEACH = "\033[38;5;216m"
    SKY = "\033[38;5;117m"
    CORAL = "\033[38;5;210m"
    SAGE = "\033[38;5;151m"
    YELLOW = "\033[38;5;221m"
    DIM = "\033[2m"
    BOLD = "\033[1m"
    NC = "\033[0m"


C = Colors

# ═══════════════════════════════════════════════════════════════════
# HELPERS
# ═══════════════════════════════════════════════════════════════════


def get_project_dir():
    """Get project directory from current working directory.

    Walks up from CWD to find a directory containing .ralph/
    """
    cwd = Path.cwd()

    # Check CWD first
    if (cwd / ".ralph").is_dir():
        return cwd

    # Walk up to find .ralph/
    for parent in cwd.parents:
        if (parent / ".ralph").is_dir():
            return parent

    # Fallback to CWD
    return cwd


def find_prd_file(project_dir: Path) -> Path | None:
    """Find the active PRD file.

    Searches in order:
    1. .ralph/runs/run-NNN-*/prd.json with status "active" (newest first)
    2. Legacy locations: .ralph/prd-*.json, .ralph/prd.json, prd.json
    """
    runs_dir = project_dir / ".ralph" / "runs"

    # Check runs folder for active PRDs (newest run number first)
    if runs_dir.exists():
        run_dirs = sorted(
            [d for d in runs_dir.iterdir() if d.is_dir() and d.name.startswith("run-")],
            key=lambda d: d.name,
            reverse=True,
        )
        for run_dir in run_dirs:
            prd_file = run_dir / "prd.json"
            if prd_file.exists():
                try:
                    prd = load_prd(prd_file)
                    if prd.get("status") == "active":
                        return prd_file
                except (json.JSONDecodeError, OSError):
                    pass

    # Legacy fallback
    legacy_candidates = [
        project_dir / ".ralph" / "prd.json",
        project_dir / "prd.json",
    ]
    for candidate in legacy_candidates:
        if candidate.exists():
            return candidate
    return None


def get_run_dir(prd_file: Path) -> Path | None:
    """Get the run directory for a PRD file, if it's in a run folder."""
    if prd_file.parent.name.startswith("run-"):
        return prd_file.parent
    return None


def load_prd(prd_file: Path) -> dict:
    """Load PRD JSON file."""
    with open(prd_file) as f:
        return json.load(f)


def save_prd(prd_file: Path, prd: dict):
    """Save PRD JSON file."""
    with open(prd_file, "w") as f:
        json.dump(prd, f, indent=2)
        f.write("\n")


def get_prd_title(prd: dict) -> str:
    """Get PRD title."""
    return prd.get("title", "Untitled PRD")


def count_tasks_by_status(prd: dict) -> dict:
    """Count tasks by status."""
    counts = {"open": 0, "completed": 0, "total": 0}
    for story in prd.get("stories", []):
        status = story.get("status", "open")
        counts[status] = counts.get(status, 0) + 1
        counts["total"] += 1
    return counts


def get_completed_task_ids(prd: dict) -> set:
    """Get set of completed task IDs."""
    return {s["id"] for s in prd.get("stories", []) if s.get("status") == "completed"}


def deps_met(story: dict, completed_ids: set) -> bool:
    """Check if all dependencies are met."""
    for dep in story.get("dependencies", []):
        if dep not in completed_ids:
            return False
    return True


def get_open_tasks(prd: dict) -> list:
    """Get list of open tasks with dependency status."""
    completed_ids = get_completed_task_ids(prd)
    tasks = []
    for story in prd.get("stories", []):
        if story.get("status") == "open":
            ready = deps_met(story, completed_ids)
            tasks.append(
                {
                    "id": story["id"],
                    "title": story["title"],
                    "ready": ready,
                }
            )
    return tasks


def get_next_task(prd: dict) -> dict | None:
    """Get next available task (open with deps met)."""
    completed_ids = get_completed_task_ids(prd)
    for story in prd.get("stories", []):
        if story.get("status") == "open" and deps_met(story, completed_ids):
            return story
    return None


def is_milestone_task(task: dict) -> bool:
    """Check if a task is a milestone (requires manual verification)."""
    task_id = task.get("id", "")
    category = task.get("category", "")
    title = task.get("title", "").lower()
    return (
        task_id.startswith("M")
        or category == "milestone"
        or "milestone" in title
    )


def get_unverified_milestone(prd: dict) -> dict | None:
    """Get the first completed milestone that hasn't been verified or skipped.

    Returns the milestone task dict if found, None otherwise.
    """
    for story in prd.get("stories", []):
        if (
            story.get("status") == "completed"
            and is_milestone_task(story)
            and not story.get("verified", False)
            and not story.get("skipped", False)
        ):
            return story
    return None


def mark_milestone_verified(prd_file: Path, prd: dict, milestone_id: str):
    """Mark a milestone as verified in the PRD."""
    for story in prd.get("stories", []):
        if story["id"] == milestone_id:
            story["verified"] = True
            break
    save_prd(prd_file, prd)


def mark_milestone_skipped(prd_file: Path, prd: dict, milestone_id: str):
    """Mark a milestone as skipped in the PRD."""
    for story in prd.get("stories", []):
        if story["id"] == milestone_id:
            story["skipped"] = True
            break
    save_prd(prd_file, prd)


def get_cycle_stage(project_dir: Path) -> str:
    """Get current cycle stage from CYCLE.md."""
    cycle_file = project_dir / ".ralph" / "CYCLE.md"
    if not cycle_file.exists():
        return "Unknown"

    content = cycle_file.read_text()
    for line in content.split("\n"):
        if "STAGE" in line and "▶" in line:
            stage = line.split("▶")[-1].strip()
            stage = stage.replace("║", "").strip()
            return stage
    return "Unknown"


def run_command(cmd: list, cwd: Path | None = None, capture: bool = True) -> tuple:
    """Run a command and return (returncode, stdout, stderr)."""
    result = subprocess.run(
        cmd,
        cwd=cwd,
        capture_output=capture,
        text=True,
    )
    return result.returncode, result.stdout, result.stderr


def git_has_changes(project_dir: Path) -> bool:
    """Check if there are uncommitted changes."""
    run_command(["git", "add", "-A", "."], cwd=project_dir)
    code, _, _ = run_command(["git", "diff", "--staged", "--quiet"], cwd=project_dir)
    return code != 0


def git_commit(project_dir: Path, message: str):
    """Commit staged changes."""
    run_command(["git", "add", "-A", "."], cwd=project_dir)
    run_command(["git", "commit", "-m", message, "--quiet"], cwd=project_dir)


def git_rev_parse(project_dir: Path) -> str:
    """Get current commit hash."""
    code, stdout, _ = run_command(["git", "rev-parse", "HEAD"], cwd=project_dir)
    return stdout.strip() if code == 0 else "none"


def git_commit_count(project_dir: Path, from_hash: str, to_hash: str) -> int:
    """Count commits between two hashes."""
    code, stdout, _ = run_command(
        ["git", "rev-list", "--count", f"{from_hash}..{to_hash}"], cwd=project_dir
    )
    return int(stdout.strip()) if code == 0 else 0


# ═══════════════════════════════════════════════════════════════════
# MILESTONE VALIDATION
# ═══════════════════════════════════════════════════════════════════


def extract_code_blocks(description: str) -> list:
    """Extract code blocks from milestone description.

    Returns list of dicts with 'lang', 'title', and 'commands' keys.
    """
    import re

    # Handle JSON escaped newlines
    description = description.replace("\\n", "\n")

    blocks = []

    # Find code blocks with their preceding section titles
    # Look for ## Title followed by ```lang ... ```
    pattern = r'## ([^\n]+)\n```(\w*)\n(.*?)```'

    for match in re.finditer(pattern, description, re.DOTALL):
        title = match.group(1).strip()
        lang = match.group(2) or "bash"
        code = match.group(3).strip()

        if lang in ("bash", "sh", "shell", ""):
            # Parse commands, handling multi-line strings
            commands = []
            lines = code.split("\n")
            i = 0
            while i < len(lines):
                line = lines[i]
                stripped = line.strip()

                # Skip empty lines and comments
                if not stripped or stripped.startswith("#"):
                    i += 1
                    continue

                # Check if line starts a multi-line python -c command
                # These start with python3 -c " and end with a line that has just "
                if ('python3 -c "' in stripped or 'python -c "' in stripped) and not stripped.endswith('""'):
                    # Collect lines until closing quote (line ending with just ")
                    multi_line = [line]
                    i += 1
                    while i < len(lines):
                        next_line = lines[i]
                        multi_line.append(next_line)
                        # Check if this line ends the multi-line command
                        if next_line.strip() == '"' or next_line.strip().endswith('"'):
                            i += 1
                            break
                        i += 1
                    # Join as single command
                    commands.append("\n".join(multi_line))
                else:
                    commands.append(stripped)
                    i += 1

            if commands:
                blocks.append({
                    "title": title,
                    "lang": lang,
                    "commands": commands,
                })

    return blocks


def run_milestone_validation(project_dir: Path, milestone: dict) -> tuple:
    """Run validation commands from milestone description.

    Returns (passed: int, failed: int, results: list)
    """
    description = milestone.get("description", "")
    blocks = extract_code_blocks(description)

    if not blocks:
        return 0, 0, []

    results = []
    passed = 0
    failed = 0

    print(f"  {C.BOLD}{C.LAVENDER}Running Milestone Validation{C.NC}")
    print()

    # Track current directory for cd commands
    cwd = project_dir

    for block in blocks:
        title = block["title"]
        commands = block["commands"]

        print(f"  {C.YELLOW}▸{C.NC} {C.SAGE}{title}{C.NC}")

        block_passed = True
        for cmd in commands:
            # Handle cd commands specially - update cwd for subsequent commands
            if cmd.startswith("cd "):
                new_dir = cmd[3:].strip()
                if new_dir == "../..":
                    cwd = cwd.parent.parent
                elif new_dir == "..":
                    cwd = cwd.parent
                elif new_dir.startswith("/"):
                    cwd = Path(new_dir)
                else:
                    cwd = cwd / new_dir
                print(f"    {C.DIM}$ {cmd}{C.NC}")
                continue

            # Handle source commands - skip them (venv activation)
            if cmd.startswith("source "):
                print(f"    {C.DIM}$ {cmd} (skipped){C.NC}")
                continue

            # Handle export commands - set in environment
            if cmd.startswith("export "):
                print(f"    {C.DIM}$ {cmd}{C.NC}")
                # Parse export VAR=value
                var_part = cmd[7:].strip()
                if "=" in var_part:
                    var_name, var_value = var_part.split("=", 1)
                    # Expand ${HOME} and similar
                    var_value = var_value.strip('"').strip("'")
                    var_value = os.path.expandvars(var_value)
                    os.environ[var_name] = var_value
                continue

            # Handle pip install - skip
            if cmd.startswith("pip ") or cmd.startswith("pip3 "):
                print(f"    {C.DIM}$ {cmd} (skipped){C.NC}")
                continue

            # Handle python venv creation - skip
            if "venv" in cmd and "python" in cmd:
                print(f"    {C.DIM}$ {cmd} (skipped){C.NC}")
                continue

            # Run the command
            print(f"    {C.DIM}${C.NC} {C.SKY}{cmd}{C.NC}")

            try:
                result = subprocess.run(
                    cmd,
                    shell=True,
                    cwd=cwd,
                    capture_output=True,
                    text=True,
                    timeout=120,
                    env=os.environ.copy(),
                )

                if result.returncode == 0:
                    print(f"      {C.MINT}✓{C.NC} {C.DIM}exit 0{C.NC}")
                else:
                    print(f"      {C.CORAL}✗{C.NC} {C.DIM}exit {result.returncode}{C.NC}")
                    if result.stderr:
                        # Show first line of error
                        err_line = result.stderr.strip().split("\n")[0][:60]
                        print(f"      {C.DIM}{err_line}{C.NC}")
                    block_passed = False

            except subprocess.TimeoutExpired:
                print(f"      {C.CORAL}✗{C.NC} {C.DIM}timeout{C.NC}")
                block_passed = False
            except Exception as e:
                print(f"      {C.CORAL}✗{C.NC} {C.DIM}{str(e)[:50]}{C.NC}")
                block_passed = False

        if block_passed:
            passed += 1
            results.append((title, True, None))
        else:
            failed += 1
            results.append((title, False, "Command failed"))

        print()

    # Summary
    print(f"  {C.DIM}{'─' * 55}{C.NC}")
    if failed == 0:
        print(f"  {C.MINT}✓ All validation steps passed ({passed}/{passed}){C.NC}")
    else:
        print(f"  {C.CORAL}✗ Validation: {passed} passed, {failed} failed{C.NC}")
    print()

    return passed, failed, results


# ═══════════════════════════════════════════════════════════════════
# DISPLAY
# ═══════════════════════════════════════════════════════════════════


def print_header(project_name: str = ""):
    """Print the Ralph header."""
    display_name = project_name or "Ralph"
    # Pad/truncate to fit the box (11 chars for project name area)
    display_name = display_name[:11].ljust(11)
    print()
    print(f"{C.SKY}  ┌─────────────────────────────────────────────────────────┐{C.NC}")
    print(
        f"{C.SKY}  │{C.NC}     {C.PINK}{display_name}{C.NC} {C.DIM}~ Ralph Loop Runner{C.NC}                    {C.SKY}│{C.NC}"
    )
    print(f"{C.SKY}  └─────────────────────────────────────────────────────────┘{C.NC}")
    print()


def print_task_list(tasks: list, indent: str = "  "):
    """Print list of tasks with status indicators."""
    for task in tasks:
        indicator = "→" if task["ready"] else "⏸"
        print(f"{indent}{indicator} {task['id']}: {task['title']}")


def print_completed_tasks(prd: dict, indent: str = "    "):
    """Print completed tasks."""
    for story in prd.get("stories", []):
        if story.get("status") == "completed":
            # Show verification status for milestones
            if is_milestone_task(story):
                if story.get("verified", False):
                    print(f"{indent}{C.MINT}✓{C.NC} {story['id']}: {story['title']} {C.MINT}[verified]{C.NC}")
                elif story.get("skipped", False):
                    print(f"{indent}{C.PEACH}⊘{C.NC} {story['id']}: {story['title']} {C.PEACH}[skipped]{C.NC}")
                else:
                    print(f"{indent}{C.YELLOW}⚠{C.NC} {story['id']}: {story['title']} {C.YELLOW}[needs verification]{C.NC}")
            else:
                print(f"{indent}✓ {story['id']}: {story['title']}")


# ═══════════════════════════════════════════════════════════════════
# COMMANDS
# ═══════════════════════════════════════════════════════════════════


def get_ralph_implementation_dir() -> Path:
    """Get the directory where ralph's implementation lives."""
    # This script's actual location (resolving symlinks)
    return Path(__file__).resolve().parent


def verify_installation(target_dir: Path, ralph_impl_dir: Path) -> bool:
    """Verify an existing ralph installation and report/fix issues."""
    ralph_dir = target_dir / ".ralph"
    ralph_script = ralph_impl_dir / "ralph"
    issues = []
    fixed = []

    print(f"  {C.BOLD}{C.LAVENDER}Verifying Ralph Installation{C.NC}")
    print()
    print(f"  {C.DIM}Project:{C.NC}   {C.SAGE}{target_dir}{C.NC}")
    print(f"  {C.DIM}Ralph at:{C.NC}  {C.SAGE}{ralph_impl_dir}{C.NC}")
    print()

    # Check symlink
    symlink_path = ralph_dir / "ralph"
    if symlink_path.exists():
        if symlink_path.is_symlink():
            link_target = symlink_path.resolve()
            if link_target == ralph_script:
                print(f"  {C.MINT}✓{C.NC} Symlink correct: .ralph/ralph → {ralph_script}")
            else:
                print(f"  {C.CORAL}✗{C.NC} Symlink points to wrong location: {link_target}")
                issues.append(("symlink_wrong", symlink_path, ralph_script))
        else:
            print(f"  {C.CORAL}✗{C.NC} .ralph/ralph is not a symlink (it's a regular file)")
            issues.append(("symlink_not_link", symlink_path, ralph_script))
    else:
        print(f"  {C.CORAL}✗{C.NC} Missing: .ralph/ralph symlink")
        issues.append(("symlink_missing", symlink_path, ralph_script))

    # Check required directories
    runs_dir = ralph_dir / "runs"
    if runs_dir.exists() and runs_dir.is_dir():
        print(f"  {C.MINT}✓{C.NC} Directory exists: .ralph/runs/")
    else:
        print(f"  {C.CORAL}✗{C.NC} Missing: .ralph/runs/ directory")
        issues.append(("dir_missing", runs_dir))

    # Check required files
    for filename in ("README.md", "CYCLE.md", "NOTES.md"):
        filepath = ralph_dir / filename
        if filepath.exists():
            print(f"  {C.MINT}✓{C.NC} File exists: .ralph/{filename}")
        else:
            print(f"  {C.YELLOW}○{C.NC} Missing: .ralph/{filename}")
            issues.append(("file_missing", filepath, filename))

    print()

    if not issues:
        print(f"  {C.MINT}✓ Installation verified - everything looks good!{C.NC}")
        print()
        return True

    # Offer to fix issues
    print(f"  {C.YELLOW}Found {len(issues)} issue(s). Attempting to fix...{C.NC}")
    print()

    for issue in issues:
        issue_type = issue[0]

        if issue_type == "symlink_missing":
            symlink_path, target = issue[1], issue[2]
            symlink_path.symlink_to(target)
            print(f"  {C.MINT}✓{C.NC} Created symlink: .ralph/ralph")
            fixed.append(issue)

        elif issue_type == "symlink_wrong":
            symlink_path, target = issue[1], issue[2]
            symlink_path.unlink()
            symlink_path.symlink_to(target)
            print(f"  {C.MINT}✓{C.NC} Fixed symlink: .ralph/ralph")
            fixed.append(issue)

        elif issue_type == "symlink_not_link":
            symlink_path, target = issue[1], issue[2]
            # Backup the file first
            backup_path = symlink_path.with_suffix(".backup")
            symlink_path.rename(backup_path)
            symlink_path.symlink_to(target)
            print(f"  {C.MINT}✓{C.NC} Replaced file with symlink (backup: {backup_path.name})")
            fixed.append(issue)

        elif issue_type == "dir_missing":
            dir_path = issue[1]
            dir_path.mkdir(parents=True)
            print(f"  {C.MINT}✓{C.NC} Created directory: {dir_path.relative_to(target_dir)}")
            fixed.append(issue)

        elif issue_type == "file_missing":
            # Don't auto-create content files - just warn
            filepath, filename = issue[1], issue[2]
            print(f"  {C.DIM}○{C.NC} Skipped: .ralph/{filename} (create manually or reinstall)")

    print()

    unfixed = len(issues) - len(fixed)
    if unfixed == 0:
        print(f"  {C.MINT}✓ All issues fixed!{C.NC}")
    else:
        print(f"  {C.YELLOW}○ {unfixed} issue(s) need manual attention{C.NC}")

    print()
    return unfixed == 0


def cmd_install(args, target_dir: Path):
    """Install ralph in a new project directory, or verify existing installation."""
    ralph_impl_dir = get_ralph_implementation_dir()
    ralph_script = ralph_impl_dir / "ralph"
    ralph_dir = target_dir / ".ralph"

    # If already installed, verify the installation
    if ralph_dir.exists():
        return verify_installation(target_dir, ralph_impl_dir)

    print(f"  {C.BOLD}{C.LAVENDER}Installing Ralph{C.NC}")
    print()
    print(f"  {C.DIM}Target:{C.NC}    {C.SAGE}{target_dir}{C.NC}")
    print(f"  {C.DIM}Ralph at:{C.NC}  {C.SAGE}{ralph_impl_dir}{C.NC}")
    print()

    # Create directory structure
    ralph_dir.mkdir(parents=True)
    (ralph_dir / "runs").mkdir()

    # Create symlink to ralph script
    symlink_path = ralph_dir / "ralph"
    symlink_path.symlink_to(ralph_script)
    print(f"  {C.MINT}✓{C.NC} Created symlink: .ralph/ralph")

    # Create README.md
    readme_content = f"""# Ralph - Development Loop Runner

This project uses **Ralph**, a development iteration system for Claude Code.

## Quick Start

```bash
.ralph/ralph run      # Execute PRD tasks
.ralph/ralph info     # Show current status
.ralph/ralph runs     # List all runs
```

## How It Works

Ralph runs Claude Code in fresh sessions to complete tasks from a PRD (Product Requirements Document).

1. **Create a PRD** in `.ralph/runs/run-NNN-description/prd.json`
2. **Run Ralph** with `.ralph/ralph run`
3. **Claude works** on one task per iteration
4. **Ralph commits** changes and moves to next task
5. **Milestones pause** for manual verification

## Directory Structure

```
.ralph/
├── ralph          → Symlink to central implementation
├── README.md      → This file
├── CYCLE.md       → Current development stage
├── NOTES.md       → User constraints & project context
└── runs/          → PRD runs
    └── run-001-*/
        ├── prd.json      → Task definitions
        └── progress.txt  → Execution log
```

## Important: Making Changes to Ralph

**DO NOT modify the ralph script in this repo.**

The `ralph` file in `.ralph/` is a symlink to the central implementation.
To find where Ralph lives, check the symlink:

```bash
ls -la .ralph/ralph
```

If you want to improve or fix Ralph:
1. Follow the symlink to find the implementation repo
2. Make your changes there
3. All projects using Ralph will get the updates

This keeps Ralph consistent across all projects and makes updates easy.

## PRD Format

PRDs are JSON files with this structure:

```json
{{
  "title": "Project Name",
  "status": "active",
  "stories": [
    {{
      "id": "001",
      "title": "Task title",
      "description": "What to do",
      "status": "open",
      "dependencies": []
    }},
    {{
      "id": "M1",
      "title": "Milestone: Review Progress",
      "category": "milestone",
      "status": "open",
      "dependencies": ["001"]
    }}
  ]
}}
```

- Task IDs starting with `M` are milestones (require manual verification)
- Dependencies must be completed before a task becomes available
- Status: `open` → `completed`

## Tips

- Read `NOTES.md` before starting - it contains important constraints
- Check `CYCLE.md` to know what development stage you're in
- Milestones pause execution for human review
- Run `ralph info` to see current progress

---

*Check `.ralph/ralph` symlink to find Ralph's implementation repo*
"""
    (ralph_dir / "README.md").write_text(readme_content)
    print(f"  {C.MINT}✓{C.NC} Created README.md")

    # Create CYCLE.md
    cycle_content = """# Development Cycle

Current stage in the development cycle.

## Stages

```
║ 1. DISCUSS & MAP    → Talk with user, explore problems
║ 2. DESIGN PRD       → Convert discussion into structured tasks
▶ 3. EXECUTE PRD      → Run ralph loop, complete tasks
║ 4. EVALUATE         → Test, review, document learnings
║ 5. NEW CYCLE        → Archive and start fresh
```

---

*Update the arrow (▶) to indicate current stage*
"""
    (ralph_dir / "CYCLE.md").write_text(cycle_content)
    print(f"  {C.MINT}✓{C.NC} Created CYCLE.md")

    # Create NOTES.md
    notes_content = """# User Notes & Directives

**This file contains important context for Claude. Read before each iteration.**

---

## Project Context

*(Describe what this project is and what you're trying to accomplish)*

---

## User Requirements

*(Add specific requirements, constraints, and preferences here)*

---

## Technical Decisions

*(Document important technical decisions and their rationale)*

---

## Constraints (Don't Do These)

*(List things that should NOT be done)*

---

## Learnings & Insights

*(Update as project progresses)*

---

*Last updated: (date)*
"""
    (ralph_dir / "NOTES.md").write_text(notes_content)
    print(f"  {C.MINT}✓{C.NC} Created NOTES.md")

    print()
    print(f"  {C.MINT}✓ Ralph installed successfully!{C.NC}")
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Next steps:{C.NC}")
    print(f"    1. Edit {C.SAGE}.ralph/NOTES.md{C.NC} with project context")
    print(f"    2. Create a PRD in {C.SAGE}.ralph/runs/run-001-description/prd.json{C.NC}")
    print(f"    3. Run {C.SAGE}.ralph/ralph run{C.NC} to start")
    print()

    return True


def apply_prereqs(project_dir: Path, blocks: list) -> Path:
    """Apply Prerequisites step: cd commands, exports, detect venv.

    Returns the working directory.
    """
    cwd = project_dir
    # Look for Prerequisites step
    for block in blocks:
        if "prereq" in block["title"].lower():
            for cmd in block["commands"]:
                cmd = cmd.strip()
                # Handle cd
                if cmd.startswith("cd "):
                    new_dir = cmd[3:].strip()
                    if new_dir.startswith("/"):
                        cwd = Path(new_dir)
                    else:
                        cwd = project_dir / new_dir
                # Handle export
                elif cmd.startswith("export "):
                    var_part = cmd[7:].strip()
                    if "=" in var_part:
                        var_name, var_value = var_part.split("=", 1)
                        var_value = var_value.strip('"').strip("'")
                        var_value = os.path.expandvars(var_value)
                        os.environ[var_name] = var_value
            break
    return cwd


def run_milestone_step(project_dir: Path, step: dict, step_num: int, initial_cwd: Path = None) -> bool:
    """Run a single milestone verification step.

    Shows description, copyable code, then executes it.
    Returns True if step passed.
    """
    title = step["title"]
    commands = step["commands"]

    print(f"  {C.BOLD}{C.LAVENDER}Step {step_num}: {title}{C.NC}")
    print()

    # Show copyable code block
    print(f"  {C.DIM}┌{'─' * 60}{C.NC}")
    for cmd in commands:
        # For multi-line commands, show each line
        for line in cmd.split("\n"):
            print(f"  {C.DIM}│{C.NC} {C.SKY}{line}{C.NC}")
    print(f"  {C.DIM}└{'─' * 60}{C.NC}")
    print()

    # Ask to run
    try:
        reply = input(f"  {C.YELLOW}Run this step? [Y/n]{C.NC} ").strip().lower()
    except (KeyboardInterrupt, EOFError):
        print()
        return False

    if reply in ("n", "no"):
        print(f"  {C.DIM}Skipped{C.NC}")
        print()
        return True  # Not a failure, just skipped

    print()

    # Track cwd for cd commands - start from prereqs cwd if provided
    cwd = initial_cwd or project_dir
    all_passed = True
    venv_python = None  # Track if we should use venv python

    for cmd in commands:
        # Handle cd commands
        if cmd.strip().startswith("cd "):
            new_dir = cmd.strip()[3:].strip()
            if new_dir == "../..":
                cwd = cwd.parent.parent
            elif new_dir == "..":
                cwd = cwd.parent
            elif new_dir.startswith("/"):
                cwd = Path(new_dir)
            else:
                cwd = cwd / new_dir
            print(f"  {C.DIM}$ cd {new_dir}{C.NC}")
            continue

        # Handle source venv - check if venv exists and set venv_python
        if cmd.strip().startswith("source ") and "venv" in cmd:
            # Extract venv path and check if it exists
            venv_path = cwd / ".venv"
            if venv_path.exists():
                venv_python = str(venv_path / "bin" / "python3")
                print(f"  {C.DIM}$ {cmd.split(chr(10))[0][:50]}{C.NC}")
                print(f"    {C.MINT}✓ Using venv: {venv_path}{C.NC}")
            else:
                print(f"  {C.DIM}$ {cmd.split(chr(10))[0][:50]} (venv not found){C.NC}")
            continue

        # Skip pip/venv creation
        if "venv" in cmd and "python" in cmd:
            print(f"  {C.DIM}$ {cmd.split(chr(10))[0][:50]}... (skipped){C.NC}")
            continue
        if cmd.strip().startswith("pip"):
            print(f"  {C.DIM}$ {cmd.split(chr(10))[0][:50]}... (skipped){C.NC}")
            continue

        # Handle export
        if cmd.strip().startswith("export "):
            var_part = cmd.strip()[7:].strip()
            if "=" in var_part:
                var_name, var_value = var_part.split("=", 1)
                var_value = var_value.strip('"').strip("'")
                var_value = os.path.expandvars(var_value)
                os.environ[var_name] = var_value
            print(f"  {C.DIM}$ {cmd.strip()}{C.NC}")
            continue

        # Replace python3 with venv python if venv is active
        actual_cmd = cmd
        if venv_python and (cmd.strip().startswith("python3 ") or cmd.strip().startswith("python ")):
            actual_cmd = cmd.replace("python3 ", f"{venv_python} ", 1).replace("python ", f"{venv_python} ", 1)

        # Show command being run
        first_line = cmd.split("\n")[0]
        if "\n" in cmd:
            print(f"  {C.DIM}${C.NC} {C.SKY}{first_line}...{C.NC} {C.DIM}(multi-line){C.NC}")
        else:
            print(f"  {C.DIM}${C.NC} {C.SKY}{cmd[:70]}{C.NC}")

        # Run the command (use actual_cmd which may have venv python substituted)
        try:
            result = subprocess.run(
                actual_cmd,
                shell=True,
                cwd=cwd,
                capture_output=True,
                text=True,
                timeout=300,
                env=os.environ.copy(),
            )

            if result.returncode == 0:
                print(f"  {C.MINT}✓ Success{C.NC}")
                # Show some output if available
                if result.stdout.strip():
                    for line in result.stdout.strip().split("\n")[:10]:
                        print(f"    {C.DIM}{line[:80]}{C.NC}")
                    if result.stdout.count("\n") > 10:
                        print(f"    {C.DIM}... ({result.stdout.count(chr(10)) - 10} more lines){C.NC}")
            else:
                print(f"  {C.CORAL}✗ Failed (exit {result.returncode}){C.NC}")
                if result.stderr.strip():
                    for line in result.stderr.strip().split("\n")[:5]:
                        print(f"    {C.CORAL}{line[:80]}{C.NC}")
                all_passed = False

        except subprocess.TimeoutExpired:
            print(f"  {C.CORAL}✗ Timeout (5 min){C.NC}")
            all_passed = False
        except Exception as e:
            print(f"  {C.CORAL}✗ Error: {e}{C.NC}")
            all_passed = False

        print()

    return all_passed


def cmd_milestone(args, project_dir: Path, prd_file: Path, prd: dict, milestone_id: str | None = None, step_num: str | None = None):
    """List milestones, show details, or run a specific step."""
    milestones = [s for s in prd.get("stories", []) if is_milestone_task(s)]

    if not milestones:
        print(f"  {C.DIM}No milestones found in PRD{C.NC}")
        print()
        return

    if milestone_id:
        # Show details for specific milestone (case-insensitive match)
        milestone = next(
            (m for m in milestones if m["id"].lower() == milestone_id.lower()), None
        )
        if not milestone:
            print(f"  {C.CORAL}Milestone '{milestone_id}' not found{C.NC}")
            print()
            print(f"  {C.DIM}Available milestones:{C.NC}")
            for m in milestones:
                print(f"    {m['id']}: {m['title']}")
            print()
            return

        # Handle --skip flag (use actual ID from milestone for correct case)
        actual_id = milestone["id"]
        if args.skip:
            mark_milestone_skipped(prd_file, prd, actual_id)
            print(f"  {C.MINT}✓ Milestone {actual_id} marked as skipped{C.NC}")
            print(f"  {C.DIM}Ralph will no longer pause for this milestone.{C.NC}")
            print()
            return

        # Get verification steps
        blocks = extract_code_blocks(milestone.get("description", ""))

        # Handle step execution: ralph milestone M1 <step>
        if step_num:
            try:
                step_idx = int(step_num) - 1  # 1-indexed for user
                if step_idx < 0 or step_idx >= len(blocks):
                    print(f"  {C.CORAL}Step {step_num} not found{C.NC}")
                    print(f"  {C.DIM}Available steps: 1-{len(blocks)}{C.NC}")
                    print()
                    return
                step = blocks[step_idx]
                # Apply Prerequisites (cd, exports, etc.)
                initial_cwd = apply_prereqs(project_dir, blocks)
                if initial_cwd != project_dir:
                    print(f"  {C.DIM}Working directory: {initial_cwd}{C.NC}")
                    print()
                run_milestone_step(project_dir, step, int(step_num), initial_cwd)
                return
            except ValueError:
                print(f"  {C.CORAL}Invalid step number: {step_num}{C.NC}")
                print()
                return

        # Show milestone details
        status = milestone.get("status", "open")
        verified = milestone.get("verified", False)
        skipped = milestone.get("skipped", False)

        print(f"  {C.BOLD}{C.LAVENDER}Milestone: {milestone['id']}{C.NC}")
        print()
        print(f"  {C.SAGE}{milestone['title']}{C.NC}")
        print()

        # Status
        if status == "completed":
            if verified:
                print(f"  {C.DIM}Status:{C.NC}  {C.MINT}✓ Completed & Verified{C.NC}")
            elif skipped:
                print(f"  {C.DIM}Status:{C.NC}  {C.PEACH}⊘ Completed (skipped){C.NC}")
            else:
                print(f"  {C.DIM}Status:{C.NC}  {C.YELLOW}⚠ Completed (needs verification){C.NC}")
        else:
            print(f"  {C.DIM}Status:{C.NC}  {C.DIM}○ Open{C.NC}")

        # Dependencies
        deps = milestone.get("dependencies", [])
        if deps:
            completed_ids = get_completed_task_ids(prd)
            print(f"  {C.DIM}Depends on:{C.NC}")
            for dep_id in deps:
                dep_done = dep_id in completed_ids
                indicator = f"{C.MINT}✓{C.NC}" if dep_done else f"{C.DIM}○{C.NC}"
                # Find dep title
                dep_task = next((s for s in prd.get("stories", []) if s["id"] == dep_id), None)
                dep_title = dep_task["title"] if dep_task else "(unknown)"
                print(f"    {indicator} {dep_id}: {dep_title}")
        print()

        # Verification steps
        if blocks:
            print(f"  {C.BOLD}{C.LAVENDER}Verification Steps:{C.NC}")
            print()
            for i, block in enumerate(blocks, 1):
                print(f"    {C.PINK}{i}{C.NC}  {C.SAGE}{block['title']}{C.NC}")
                print(f"       {C.DIM}{len(block['commands'])} command(s){C.NC}")
            print()
            print(f"  {C.DIM}Run a step:{C.NC} {C.SAGE}ralph milestone {actual_id} <step>{C.NC}")
            print(f"  {C.DIM}Example:{C.NC}    {C.SAGE}ralph milestone {actual_id} 1{C.NC}")
            print()
            return  # Don't show the full description - steps are cleaner

        # Description (fallback if no steps found)
        desc = milestone.get("description", "")
        if desc:
            print(f"  {C.BOLD}{C.LAVENDER}Description:{C.NC}")
            print()
            print(f"  {C.DIM}{'─' * 55}{C.NC}")
            print()
            # Handle both \\n (JSON escaped) and actual newlines
            desc_lines = desc.replace("\\n", "\n").split("\n")
            in_code_block = False
            for line in desc_lines:
                stripped = line.strip()
                # Code block markers
                if stripped.startswith("```"):
                    in_code_block = not in_code_block
                    if in_code_block:
                        lang = stripped[3:] or "code"
                        print(f"    {C.DIM}┌─ {lang} ─{'─' * (40 - len(lang))}{C.NC}")
                    else:
                        print(f"    {C.DIM}└{'─' * 45}{C.NC}")
                    continue
                # Inside code block - show as commands
                if in_code_block:
                    if stripped.startswith("#"):
                        print(f"    {C.DIM}│{C.NC} {C.DIM}{stripped}{C.NC}")
                    else:
                        print(f"    {C.DIM}│{C.NC} {C.SKY}{stripped}{C.NC}")
                    continue
                # Markdown headers (## Header)
                if stripped.startswith("## "):
                    print()
                    print(f"    {C.YELLOW}{C.BOLD}{stripped[3:]}{C.NC}")
                    continue
                if stripped.startswith("# "):
                    print()
                    print(f"    {C.CORAL}{C.BOLD}{stripped[2:]}{C.NC}")
                    continue
                # Bullet points with checkboxes - [ ] or [x]
                if stripped.startswith("- [ ]") or stripped.startswith("- [x]"):
                    checked = "[x]" in stripped[:6]
                    content = stripped[6:].strip()
                    check = f"{C.MINT}✓{C.NC}" if checked else f"{C.DIM}○{C.NC}"
                    print(f"      {check} {C.SAGE}{content}{C.NC}")
                    continue
                # Regular bullet points
                if stripped.startswith("- ") or stripped.startswith("* "):
                    content = stripped[2:]
                    print(f"    {C.MINT}•{C.NC} {C.SAGE}{content}{C.NC}")
                    continue
                # Numbered items
                if stripped and stripped[0].isdigit() and ". " in stripped[:4]:
                    num_end = stripped.index(". ")
                    num = stripped[:num_end]
                    content = stripped[num_end + 2:]
                    print(f"    {C.PINK}{num}.{C.NC} {C.SAGE}{content}{C.NC}")
                    continue
                # Empty lines
                if not stripped:
                    print()
                    continue
                # Regular text
                print(f"    {C.SAGE}{stripped}{C.NC}")
            print()
            print(f"  {C.DIM}{'─' * 55}{C.NC}")
            print()

        # Manual verification commands
        print(f"  {C.BOLD}{C.LAVENDER}Manual Verification Commands:{C.NC}")
        print()
        print(f"  {C.DIM}View this milestone in PRD:{C.NC}")
        print(f"    {C.SAGE}cat {prd_file.relative_to(project_dir)} | jq '.stories[] | select(.id==\"{milestone_id}\")'{C.NC}")
        print()
        print(f"  {C.DIM}View progress log:{C.NC}")
        run_dir = get_run_dir(prd_file)
        if run_dir:
            progress_file = run_dir / "progress.txt"
            print(f"    {C.SAGE}cat {progress_file.relative_to(project_dir)}{C.NC}")
        else:
            print(f"    {C.SAGE}cat .ralph/progress.txt{C.NC}")
        print()
        print(f"  {C.DIM}View git log for recent changes:{C.NC}")
        print(f"    {C.SAGE}git log --oneline -20{C.NC}")
        print()
        print(f"  {C.DIM}Check file changes:{C.NC}")
        print(f"    {C.SAGE}git diff HEAD~5 --stat{C.NC}")
        print()

        if status == "completed" and not verified:
            print(f"  {C.BOLD}{C.YELLOW}To mark as verified:{C.NC}")
            print(f"    {C.SAGE}ralph run{C.NC}  {C.DIM}(will prompt for verification){C.NC}")
            print()

    else:
        # List all milestones
        print(f"  {C.BOLD}{C.LAVENDER}Milestones{C.NC}")
        print()

        completed_ids = get_completed_task_ids(prd)

        for milestone in milestones:
            status = milestone.get("status", "open")
            verified = milestone.get("verified", False)
            skipped = milestone.get("skipped", False)
            deps = milestone.get("dependencies", [])
            deps_met = all(d in completed_ids for d in deps)

            # Determine indicator
            if status == "completed":
                if verified:
                    indicator = f"{C.MINT}✓{C.NC}"
                    status_text = f"{C.MINT}verified{C.NC}"
                elif skipped:
                    indicator = f"{C.PEACH}⊘{C.NC}"
                    status_text = f"{C.PEACH}skipped{C.NC}"
                else:
                    indicator = f"{C.YELLOW}⚠{C.NC}"
                    status_text = f"{C.YELLOW}needs verification{C.NC}"
            else:
                if deps_met:
                    indicator = f"{C.SKY}→{C.NC}"
                    status_text = f"{C.DIM}ready{C.NC}"
                else:
                    indicator = f"{C.DIM}⏸{C.NC}"
                    status_text = f"{C.DIM}blocked{C.NC}"

            print(f"  {indicator} {C.PINK}{milestone['id']}{C.NC}: {milestone['title']}")
            print(f"      {status_text}")
            print()

        print(f"  {C.DIM}View details:{C.NC} {C.SAGE}ralph milestone <id>{C.NC}")
        print(f"  {C.DIM}Skip milestone:{C.NC} {C.SAGE}ralph milestone <id> --skip{C.NC}")
        print()


def cmd_runs(args, project_dir: Path):
    """List all runs."""
    runs_dir = project_dir / ".ralph" / "runs"

    if not runs_dir.exists() or not any(runs_dir.iterdir()):
        print(f"  {C.DIM}No runs found{C.NC}")
        print()
        return

    print(f"  {C.BOLD}{C.LAVENDER}All Runs{C.NC}")
    print()

    run_dirs = sorted(
        [d for d in runs_dir.iterdir() if d.is_dir() and d.name.startswith("run-")],
        key=lambda d: d.name,
    )

    for i, run_dir in enumerate(run_dirs, 1):
        prd_file = run_dir / "prd.json"
        if prd_file.exists():
            try:
                run_prd = load_prd(prd_file)
                status = run_prd.get("status", "unknown")
                title = run_prd.get("title", "Untitled")
                counts = count_tasks_by_status(run_prd)

                if status == "active":
                    indicator = f"{C.MINT}● active{C.NC}"
                elif status == "completed":
                    indicator = f"{C.SAGE}✓ done{C.NC}"
                else:
                    indicator = f"{C.DIM}○ {status}{C.NC}"

                print(f"  {C.PINK}{i}{C.NC}  {C.SKY}{run_dir.name}{C.NC}  {indicator}")
                print(f"       {C.SAGE}{title}{C.NC}")
                print(
                    f"       {C.DIM}{counts['completed']}/{counts['total']} tasks completed{C.NC}"
                )
                print()
            except Exception:
                print(
                    f"  {C.PINK}{i}{C.NC}  {C.SKY}{run_dir.name}{C.NC}  {C.CORAL}(error reading PRD){C.NC}"
                )
                print()

    print(
        f"  {C.DIM}View details:{C.NC} {C.SAGE}ralph show <index|name>{C.NC}"
    )
    print()


def cmd_show(args, project_dir: Path):
    """Show details of a specific run."""
    run_ref = args.subarg
    if not run_ref:
        print(f"  {C.CORAL}Error: Please specify a run{C.NC}")
        print(f"  {C.DIM}Usage: ralph show <index|name>{C.NC}")
        print(f"  {C.DIM}Example: ralph show 1{C.NC}")
        print(f"  {C.DIM}Example: ralph show run-002-feature{C.NC}")
        print()
        return

    runs_dir = project_dir / ".ralph" / "runs"
    if not runs_dir.exists():
        print(f"  {C.DIM}No runs found{C.NC}")
        print()
        return

    run_dirs = sorted(
        [d for d in runs_dir.iterdir() if d.is_dir() and d.name.startswith("run-")],
        key=lambda d: d.name,
    )

    # Find the run by index or name
    run_dir = None
    try:
        idx = int(run_ref) - 1  # 1-indexed for user
        if 0 <= idx < len(run_dirs):
            run_dir = run_dirs[idx]
    except ValueError:
        # Try matching by name
        for d in run_dirs:
            if d.name == run_ref or run_ref in d.name:
                run_dir = d
                break

    if not run_dir:
        print(f"  {C.CORAL}Run not found: {run_ref}{C.NC}")
        print()
        print(f"  {C.DIM}Available runs:{C.NC}")
        for i, d in enumerate(run_dirs, 1):
            print(f"    {i}. {d.name}")
        print()
        return

    prd_file = run_dir / "prd.json"
    if not prd_file.exists():
        print(f"  {C.CORAL}No PRD found in {run_dir.name}{C.NC}")
        print()
        return

    prd = load_prd(prd_file)
    counts = count_tasks_by_status(prd)

    # Header
    print(f"  {C.BOLD}{C.LAVENDER}Run:{C.NC} {C.SAGE}{run_dir.name}{C.NC}")
    print()
    print(f"  {C.DIM}Title{C.NC}         {C.SAGE}{get_prd_title(prd)}{C.NC}")
    print(f"  {C.DIM}Status{C.NC}        {C.SAGE}{prd.get('status', 'unknown')}{C.NC}")
    print(f"  {C.DIM}Created{C.NC}       {C.SAGE}{prd.get('created', 'unknown')}{C.NC}")
    print(f"  {C.DIM}Progress{C.NC}      {C.SAGE}{counts['completed']}{C.NC}{C.DIM}/{C.NC}{C.SAGE}{counts['total']}{C.NC} {C.DIM}tasks{C.NC}")
    print()

    # Tasks
    stories = prd.get("stories", [])
    if stories:
        print(f"  {C.BOLD}{C.LAVENDER}Tasks:{C.NC}")
        print()

        # Group by category
        by_category = {}
        for story in stories:
            cat = story.get("category", "general")
            if cat not in by_category:
                by_category[cat] = []
            by_category[cat].append(story)

        for cat, tasks in by_category.items():
            if len(by_category) > 1:
                print(f"  {C.YELLOW}{cat}{C.NC}")
            for task in tasks:
                status = task.get("status", "open")
                if status == "completed":
                    icon = f"{C.MINT}✓{C.NC}"
                else:
                    icon = f"{C.DIM}○{C.NC}"
                is_ms = is_milestone_task(task)
                ms_marker = f" {C.PINK}[M]{C.NC}" if is_ms else ""
                print(f"    {icon} {C.PINK}{task['id']}{C.NC}: {task['title']}{ms_marker}")
            print()

    # Progress file
    progress_file = run_dir / "progress.txt"
    if progress_file.exists():
        print(f"  {C.DIM}Progress log:{C.NC} {C.SAGE}{progress_file.relative_to(project_dir)}{C.NC}")

    # Actions
    if prd.get("status") == "paused":
        print()
        print(f"  {C.DIM}To resume this run:{C.NC}")
        print(f"    {C.SAGE}# Edit PRD status to 'active'{C.NC}")
    print()


def cmd_info(args, project_dir: Path, prd_file: Path, prd: dict):
    """Show current cycle status and PRD details."""
    counts = count_tasks_by_status(prd)

    print(f"  {C.BOLD}{C.LAVENDER}Current Cycle{C.NC}")
    print()

    stage = get_cycle_stage(project_dir)
    print(f"  {C.DIM}Stage{C.NC}         {C.MINT}{stage}{C.NC}")
    print(f"  {C.DIM}PRD{C.NC}           {C.SAGE}{get_prd_title(prd)}{C.NC}")
    print(
        f"  {C.DIM}File{C.NC}          {C.SAGE}{prd_file.relative_to(project_dir)}{C.NC}"
    )
    print(
        f"  {C.DIM}Progress{C.NC}      {C.SAGE}{counts['completed']}{C.NC}{C.DIM}/{C.NC}{C.SAGE}{counts['total']}{C.NC} {C.DIM}tasks completed{C.NC}"
    )
    print()

    print(f"  {C.BOLD}{C.LAVENDER}Tasks{C.NC}")
    print()

    if counts["completed"] > 0:
        print(f"  {C.DIM}Completed:{C.NC}")
        print_completed_tasks(prd)
        print()

    open_tasks = get_open_tasks(prd)
    if open_tasks:
        ready_count = sum(1 for t in open_tasks if t["ready"])
        print(
            f"  {C.DIM}Open:{C.NC} {C.DIM}({ready_count} ready, {len(open_tasks) - ready_count} blocked){C.NC}"
        )
        for task in open_tasks:
            indicator = "→" if task["ready"] else "⏸"
            print(f"    {indicator} {task['id']}: {task['title']}")
        print()

    notes_file = project_dir / ".ralph" / "NOTES.md"
    if notes_file.exists():
        print(f"  {C.DIM}See notes:{C.NC} {C.SAGE}cat .ralph/NOTES.md{C.NC}")
        print()


def cmd_run(args, project_dir: Path, prd_file: Path, prd: dict):
    """Run the Ralph loop."""
    counts = count_tasks_by_status(prd)
    open_tasks = get_open_tasks(prd)
    next_task = get_next_task(prd)

    print(f"  {C.BOLD}{C.LAVENDER}PRD:{C.NC} {C.SAGE}{get_prd_title(prd)}{C.NC}")
    print(f"  {C.DIM}File:{C.NC} {C.SAGE}{prd_file.relative_to(project_dir)}{C.NC}")
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Configuration:{C.NC}")
    print(f"  {C.DIM}Project{C.NC}       {C.SAGE}{project_dir}{C.NC}")
    print(f"  {C.DIM}Max iters{C.NC}     {C.SAGE}{args.max_iterations}{C.NC}")
    print(f"  {C.DIM}Tasks open{C.NC}    {C.SAGE}{counts['open']}{C.NC}")
    print()

    if counts["open"] == 0:
        print(f"  {C.MINT}✓ All tasks already complete!{C.NC}")
        print()
        return

    ready_tasks = [t for t in open_tasks if t["ready"]]
    print(
        f"  {C.BOLD}{C.LAVENDER}Ready Tasks:{C.NC} {C.DIM}({len(ready_tasks)} ready to execute){C.NC}"
    )
    for task in ready_tasks[:5]:
        print(f"    → {task['id']}: {task['title']}")
    if len(ready_tasks) > 5:
        print(f"    {C.DIM}... and {len(ready_tasks) - 5} more{C.NC}")
    print()

    if next_task:
        print(f"  {C.BOLD}{C.YELLOW}First task to execute:{C.NC}")
        print(f"  {C.MINT}▸ {next_task['id']}{C.NC} {C.SAGE}{next_task['title']}{C.NC}")
        print()
    else:
        print(f"  {C.CORAL}✗ No tasks available (check dependencies){C.NC}")
        print()
        return

    # Check for unverified milestones BEFORE asking to proceed (unless skipping)
    if not args.skip_milestones:
        unverified = get_unverified_milestone(prd)
    else:
        unverified = None
        print(f"  {C.DIM}(Skipping milestone verification){C.NC}")
        print()

    if unverified:
        print(
            f"  {C.SKY}─────────────────────────────────────────────────────────{C.NC}"
        )
        print()
        print(f"  {C.YELLOW}{C.BOLD}🛑 UNVERIFIED MILESTONE: {unverified['id']}{C.NC}")
        print(f"  {C.SAGE}{unverified['title']}{C.NC}")
        print()
        print(f"  {C.DIM}This milestone needs verification before continuing.{C.NC}")
        print(f"  {C.DIM}For full details:{C.NC} {C.SAGE}ralph milestone {unverified['id']}{C.NC}")
        print()
        try:
            reply = input(
                f"  {C.YELLOW}Mark as verified and continue? [y/N]{C.NC} "
            ).strip().lower()
        except (KeyboardInterrupt, EOFError):
            print()
            print()
            print(f"  {C.PEACH}Cancelled.{C.NC}")
            print()
            return

        if reply not in ("y", "yes"):
            print()
            print(f"  {C.PEACH}Run 'ralph milestone {unverified['id']}' to review.{C.NC}")
            print()
            return

        # Mark milestone as verified
        mark_milestone_verified(prd_file, prd, unverified["id"])
        print()
        print(f"  {C.MINT}✓ Milestone {unverified['id']} marked as verified{C.NC}")
        print()

        # Check if there are more unverified milestones
        prd = load_prd(prd_file)
        next_unverified = get_unverified_milestone(prd)
        if next_unverified:
            print(
                f"  {C.PEACH}Note: There are more unverified milestones. Run again to verify.{C.NC}"
            )
            print()
            return

    # Now ask to proceed (after milestone check)
    if not args.yes:
        print(
            f"  {C.SKY}─────────────────────────────────────────────────────────{C.NC}"
        )
        print()
        print(f"  {C.YELLOW}Ready to start Ralph loop.{C.NC}")
        print(
            f"  {C.DIM}This will run Claude Code up to {args.max_iterations} times.{C.NC}"
        )
        print()

        try:
            reply = input("  Proceed? [y/N] ").strip().lower()
        except (KeyboardInterrupt, EOFError):
            print()
            print()
            print(f"  {C.PEACH}Cancelled.{C.NC}")
            print()
            return

        print()

        if reply not in ("y", "yes"):
            print(f"  {C.PEACH}Cancelled.{C.NC}")
            print()
            return

    # Setup
    run_dir = get_run_dir(prd_file)
    if run_dir:
        progress_file = run_dir / "progress.txt"
    else:
        progress_file = project_dir / ".ralph" / "progress.txt"
    notes_file = project_dir / ".ralph" / "NOTES.md"

    # Commit any uncommitted changes
    if git_has_changes(project_dir):
        print(f"  {C.PEACH}Found uncommitted changes from previous run{C.NC}")
        git_commit(
            project_dir,
            "[ralph] Recover uncommitted changes from previous run\n\n"
            "Co-Authored-By: Claude <noreply@anthropic.com>",
        )
        print(f"  {C.MINT}✓ Previous changes committed{C.NC}")
        print()

    # Main loop
    for i in range(1, args.max_iterations + 1):
        prd = load_prd(prd_file)
        counts = count_tasks_by_status(prd)
        next_task = get_next_task(prd)

        print(
            f"  {C.SKY}─────────────────────────────────────────────────────────{C.NC}"
        )
        print()
        print(
            f"  {C.LAVENDER}Iteration {C.PINK}{i}{C.LAVENDER} of {C.PINK}{args.max_iterations}{C.NC}    {C.DIM}remaining: {counts['open']} tasks{C.NC}"
        )

        if counts["open"] == 0:
            print(f"  {C.MINT}✓ All tasks complete{C.NC}")
            print()
            break

        if not next_task:
            print(f"  {C.CORAL}✗ No available tasks (check dependencies){C.NC}")
            print()
            break

        print(f"  {C.MINT}▸ {next_task['id']}{C.NC} {C.SAGE}{next_task['title']}{C.NC}")
        print()

        start_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        commit_before = git_rev_parse(project_dir)

        prd_title = get_prd_title(prd)
        prompt = f"""You are working on a development project managed by Ralph.

## Project: {project_dir.name}
## PRD: {prd_title}

## Instructions

1. Read the PRD file: {prd_file}
2. Read progress file: {progress_file}
3. Read notes file: {notes_file} (important user constraints and project context!)
4. Find the FIRST task with status "open" whose dependencies are all "completed"
5. Work on that ONE task completely
6. When done:
   - Update the PRD: change the task's status from "open" to "completed"
   - Append to progress.txt what you did, including:
     - Task ID and title
     - What was accomplished
     - Any files created/modified
     - Any issues encountered
   - Make sure all your work is saved to files

## Important Rules

- Complete ONE task per iteration, then stop
- Read NOTES.md for user constraints and project context
- Create all necessary directories and files
- Write working, tested code
- Update both the PRD AND progress.txt before finishing
- If a task cannot be completed, document why in progress.txt and move on
- MILESTONE tasks (IDs starting with M): These are verification checkpoints.
  Mark them complete after documenting in progress.txt what was built and
  noting that manual verification is recommended.

Start by reading the PRD, progress, and notes files, then work on the next available task.
"""

        print(f"  {C.DIM}Claude is working on task {next_task['id']}...{C.NC}")

        subprocess.run(
            ["claude", "--print", "--dangerously-skip-permissions", str(project_dir)],
            input=prompt,
            capture_output=True,
            text=True,
        )

        end_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"  {C.DIM}Completed at {end_time}{C.NC}")
        print()

        commit_after = git_rev_parse(project_dir)

        if commit_before != commit_after and commit_before != "none":
            commits_made = git_commit_count(project_dir, commit_before, commit_after)
            print(f"  {C.MINT}✓ Claude made {commits_made} commit(s){C.NC}")

        if git_has_changes(project_dir):
            git_commit(
                project_dir,
                f"[ralph] Iteration {i}: {next_task['title']}\n\n"
                f"Task: {next_task['id']}\n"
                f"Time: {start_time} - {end_time}\n\n"
                "Co-Authored-By: Claude <noreply@anthropic.com>",
            )
            print(f"  {C.MINT}✓ Additional changes committed{C.NC}")
        elif commit_before == commit_after:
            print(f"  {C.PEACH}○ No changes{C.NC}")

        print()

        # Check if we just completed a milestone - pause for verification
        prd = load_prd(prd_file)
        task_now = next((s for s in prd.get("stories", []) if s["id"] == next_task["id"]), None)
        if task_now and task_now.get("status") == "completed" and is_milestone_task(next_task):
            print(
                f"  {C.SKY}═══════════════════════════════════════════════════════════{C.NC}"
            )
            print()
            print(f"  {C.YELLOW}{C.BOLD}🛑 MILESTONE REACHED: {next_task['id']}{C.NC}")
            print(f"  {C.SAGE}{next_task['title']}{C.NC}")
            print()
            print(f"  {C.DIM}Ralph has paused for manual verification.{C.NC}")
            print()
            print(f"  {C.MINT}Run verification steps:{C.NC}")
            print(f"    {C.SAGE}ralph milestone {next_task['id']}{C.NC}       {C.DIM}# See all steps{C.NC}")
            print(f"    {C.SAGE}ralph milestone {next_task['id']} 1{C.NC}     {C.DIM}# Run step 1{C.NC}")
            print()
            print(f"  {C.DIM}When verified, run:{C.NC} {C.SAGE}ralph run{C.NC}")
            print()
            print(
                f"  {C.SKY}═══════════════════════════════════════════════════════════{C.NC}"
            )
            print()
            return

        time.sleep(1)

    prd = load_prd(prd_file)
    counts = count_tasks_by_status(prd)

    print(f"  {C.SKY}─────────────────────────────────────────────────────────{C.NC}")
    print()
    print(f"  {C.LAVENDER}Loop complete{C.NC}")
    print(
        f"  {C.DIM}Iterations:{C.NC} {C.SAGE}{i}{C.NC}    {C.DIM}Remaining:{C.NC} {C.SAGE}{counts['open']}{C.NC}"
    )
    print()


# ═══════════════════════════════════════════════════════════════════
# RUN MANAGEMENT COMMANDS - Create/manage PRD runs
# ═══════════════════════════════════════════════════════════════════


def get_next_run_number(project_dir: Path) -> int:
    """Get the next available run number."""
    runs_dir = project_dir / ".ralph" / "runs"
    if not runs_dir.exists():
        return 1

    max_num = 0
    for d in runs_dir.iterdir():
        if d.is_dir() and d.name.startswith("run-"):
            try:
                num = int(d.name.split("-")[1])
                max_num = max(max_num, num)
            except (ValueError, IndexError):
                pass
    return max_num + 1


def get_next_task_id(prd: dict) -> str:
    """Get the next available task ID (e.g., '013' if last was '012')."""
    max_num = 0
    for story in prd.get("stories", []):
        task_id = story.get("id", "")
        # Skip milestone IDs (start with M)
        if task_id.startswith("M"):
            continue
        try:
            num = int(task_id)
            max_num = max(max_num, num)
        except ValueError:
            pass
    return f"{max_num + 1:03d}"


def slugify(text: str) -> str:
    """Convert text to a slug for directory names."""
    import re
    text = text.lower()
    text = re.sub(r'[^a-z0-9\s-]', '', text)
    text = re.sub(r'[\s_]+', '-', text)
    text = re.sub(r'-+', '-', text)
    return text.strip('-')[:40]


def cmd_new(args, project_dir: Path):
    """Create a new run with empty PRD."""
    title = args.subarg
    if not title:
        print(f"  {C.CORAL}Error: Please provide a title{C.NC}")
        print(f"  {C.DIM}Usage: ralph new \"Run Title\"{C.NC}")
        print()
        return

    run_num = get_next_run_number(project_dir)
    slug = slugify(title)
    run_name = f"run-{run_num:03d}-{slug}"
    run_dir = project_dir / ".ralph" / "runs" / run_name

    # Create directory
    run_dir.mkdir(parents=True, exist_ok=True)

    # Create PRD
    new_prd = {
        "id": f"{run_num:03d}",
        "title": title,
        "created": datetime.now().strftime("%Y-%m-%d"),
        "status": "active",
        "description": "",
        "stories": []
    }

    prd_path = run_dir / "prd.json"
    save_prd(prd_path, new_prd)

    # Create empty progress file
    (run_dir / "progress.txt").write_text(f"# Progress Log: {title}\n\n")

    # Mark any other active PRDs as paused
    runs_dir = project_dir / ".ralph" / "runs"
    for d in runs_dir.iterdir():
        if d.is_dir() and d != run_dir:
            other_prd_file = d / "prd.json"
            if other_prd_file.exists():
                try:
                    other_prd = load_prd(other_prd_file)
                    if other_prd.get("status") == "active":
                        other_prd["status"] = "paused"
                        save_prd(other_prd_file, other_prd)
                except (json.JSONDecodeError, OSError):
                    pass

    print(f"  {C.MINT}✓ Created new run:{C.NC} {C.SAGE}{run_name}{C.NC}")
    print()
    print(f"  {C.DIM}PRD:{C.NC} {C.SAGE}{prd_path.relative_to(project_dir)}{C.NC}")
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Next steps:{C.NC}")
    print(f"    {C.SAGE}ralph add \"Task title\"{C.NC}       {C.DIM}Add tasks{C.NC}")
    print(f"    {C.SAGE}ralph compile{C.NC}                {C.DIM}Add milestones{C.NC}")
    print(f"    {C.SAGE}ralph run{C.NC}                    {C.DIM}Execute tasks{C.NC}")
    print()


def cmd_add(args, project_dir: Path, prd_file: Path, prd: dict):
    """Add a task to current PRD."""
    title = args.subarg
    if not title:
        print(f"  {C.CORAL}Error: Please provide a task title{C.NC}")
        print(f"  {C.DIM}Usage: ralph add \"Task title\"{C.NC}")
        print()
        return

    # Get description from --desc or prompt
    description = getattr(args, 'desc', '') or ""
    category = getattr(args, 'category', '') or ""

    task_id = get_next_task_id(prd)

    new_task = {
        "id": task_id,
        "title": title,
        "description": description,
        "status": "open",
        "dependencies": []
    }

    if category:
        new_task["category"] = category

    prd["stories"].append(new_task)
    save_prd(prd_file, prd)

    print(f"  {C.MINT}✓ Added task {task_id}:{C.NC} {C.SAGE}{title}{C.NC}")
    if description:
        print(f"    {C.DIM}{description[:60]}{'...' if len(description) > 60 else ''}{C.NC}")
    if category:
        print(f"    {C.DIM}Category: {category}{C.NC}")
    print()

    # Show current task count
    counts = count_tasks_by_status(prd)
    print(f"  {C.DIM}Total tasks:{C.NC} {C.SAGE}{counts['total']}{C.NC}")
    print()


# ═══════════════════════════════════════════════════════════════════
# COMPILE COMMAND - Add milestones and finalize PRD
# ═══════════════════════════════════════════════════════════════════


def cmd_compile(args, project_dir: Path, prd_file: Path, prd: dict):
    """Add milestones to PRD and finalize for execution."""
    stories = prd.get("stories", [])

    if not stories:
        print(f"  {C.CORAL}Error: No tasks in PRD{C.NC}")
        print(f"  {C.DIM}Add tasks with: ralph add \"Task title\"{C.NC}")
        print()
        return

    # Check if already has milestones
    existing_milestones = [s for s in stories if is_milestone_task(s)]
    if existing_milestones and not getattr(args, 'force', False):
        print(f"  {C.YELLOW}PRD already has {len(existing_milestones)} milestone(s){C.NC}")
        print()
        for ms in existing_milestones:
            print(f"    {C.PINK}{ms['id']}{C.NC}: {ms['title']}")
        print()
        print(f"  {C.DIM}Use --force to regenerate milestones{C.NC}")
        print()
        return

    # Remove existing milestones if --force
    if existing_milestones and getattr(args, 'force', False):
        prd["stories"] = [s for s in stories if not is_milestone_task(s)]
        stories = prd["stories"]
        print(f"  {C.DIM}Removed {len(existing_milestones)} existing milestone(s){C.NC}")
        print()

    # Get configuration
    milestone_interval = getattr(args, 'interval', 5) or 5  # Default: every 5 tasks
    by_category = getattr(args, 'by_category', True)  # Default: milestone per category

    print(f"  {C.BOLD}{C.LAVENDER}Compiling PRD:{C.NC} {C.SAGE}{get_prd_title(prd)}{C.NC}")
    print()
    print(f"  {C.DIM}Tasks:{C.NC} {len(stories)}")
    print(f"  {C.DIM}Strategy:{C.NC} {'By category' if by_category else f'Every {milestone_interval} tasks'}")
    print()

    # Group tasks by category
    categories = {}
    for story in stories:
        cat = story.get("category", "general")
        if cat not in categories:
            categories[cat] = []
        categories[cat].append(story)

    milestones_to_add = []
    milestone_num = 1

    if by_category and len(categories) > 1:
        # Add milestone after each category
        for cat, tasks in categories.items():
            if not tasks:
                continue

            task_ids = [t["id"] for t in tasks]
            last_task_id = task_ids[-1]

            milestone = {
                "id": f"M{milestone_num:02d}",
                "title": f"Milestone: Review {cat} tasks",
                "description": f"Review and verify the {cat} implementation.\n\nTasks completed:\n" +
                              "\n".join(f"- {t['id']}: {t['title']}" for t in tasks),
                "status": "open",
                "category": "milestone",
                "dependencies": task_ids
            }
            milestones_to_add.append((milestone, last_task_id))
            milestone_num += 1
    else:
        # Add milestone every N tasks
        for i in range(milestone_interval, len(stories) + 1, milestone_interval):
            batch = stories[max(0, i - milestone_interval):i]
            task_ids = [t["id"] for t in batch]

            milestone = {
                "id": f"M{milestone_num:02d}",
                "title": f"Milestone: Review tasks {task_ids[0]}-{task_ids[-1]}",
                "description": f"Review and verify implementation progress.\n\nTasks completed:\n" +
                              "\n".join(f"- {t['id']}: {t['title']}" for t in batch),
                "status": "open",
                "category": "milestone",
                "dependencies": task_ids
            }
            milestones_to_add.append((milestone, task_ids[-1]))
            milestone_num += 1

        # Add final milestone if there are remaining tasks
        remaining = len(stories) % milestone_interval
        if remaining > 0:
            batch = stories[-remaining:]
            task_ids = [t["id"] for t in batch]

            milestone = {
                "id": f"M{milestone_num:02d}",
                "title": f"Milestone: Final review",
                "description": f"Final review and verification.\n\nTasks completed:\n" +
                              "\n".join(f"- {t['id']}: {t['title']}" for t in batch),
                "status": "open",
                "category": "milestone",
                "dependencies": task_ids
            }
            milestones_to_add.append((milestone, task_ids[-1]))

    # Insert milestones into the stories list
    for milestone, after_task_id in milestones_to_add:
        # Find position after the specified task
        insert_idx = len(prd["stories"])
        for i, story in enumerate(prd["stories"]):
            if story["id"] == after_task_id:
                insert_idx = i + 1
                break
        prd["stories"].insert(insert_idx, milestone)

    # Save the PRD
    save_prd(prd_file, prd)

    print(f"  {C.MINT}✓ Added {len(milestones_to_add)} milestone(s):{C.NC}")
    print()
    for milestone, _ in milestones_to_add:
        deps_str = ", ".join(milestone["dependencies"][:3])
        if len(milestone["dependencies"]) > 3:
            deps_str += f"... +{len(milestone['dependencies']) - 3} more"
        print(f"    {C.PINK}{milestone['id']}{C.NC}: {milestone['title']}")
        print(f"        {C.DIM}depends on: {deps_str}{C.NC}")
    print()

    # Show summary
    counts = count_tasks_by_status(prd)
    print(f"  {C.BOLD}{C.LAVENDER}PRD Summary:{C.NC}")
    print(f"    {C.DIM}Total tasks:{C.NC} {counts['total']}")
    print(f"    {C.DIM}Milestones:{C.NC} {len(milestones_to_add)}")
    print()
    print(f"  {C.MINT}Ready to run:{C.NC} {C.SAGE}ralph run{C.NC}")
    print()


# ═══════════════════════════════════════════════════════════════════
# MAIN
# ═══════════════════════════════════════════════════════════════════


def print_usage():
    """Print colorful usage information."""
    project_dir = get_project_dir()
    project_name = project_dir.name
    has_ralph = (project_dir / ".ralph").is_dir()

    print()
    print(f"{C.SKY}  ┌─────────────────────────────────────────────────────────┐{C.NC}")
    print(
        f"{C.SKY}  │{C.NC}     {C.PINK}Ralph{C.NC}       {C.DIM}~ Development Loop Runner{C.NC}              {C.SKY}│{C.NC}"
    )
    print(f"{C.SKY}  └─────────────────────────────────────────────────────────┘{C.NC}")
    print()
    if has_ralph:
        print(f"  {C.BOLD}{C.LAVENDER}Project:{C.NC} {C.MINT}{project_name}{C.NC}")
        print(f"  {C.DIM}Path:{C.NC}    {C.SAGE}{project_dir}{C.NC}")
        print()
    else:
        print(f"  {C.CORAL}No .ralph/ directory found in current path{C.NC}")
        print(f"  {C.DIM}CWD: {project_dir}{C.NC}")
        print()
    print(
        f"  {C.BOLD}{C.LAVENDER}Usage:{C.NC} ralph {C.DIM}[command] [options]{C.NC}"
    )
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Commands:{C.NC}")
    print(
        f"    {C.MINT}new{C.NC}             {C.DIM}Create a new run{C.NC}"
    )
    print(
        f"    {C.MINT}add{C.NC}             {C.DIM}Add a task to current run{C.NC}"
    )
    print(
        f"    {C.MINT}compile{C.NC}         {C.DIM}Add milestones and finalize PRD{C.NC}"
    )
    print(
        f"    {C.MINT}run{C.NC}             {C.DIM}Execute PRD tasks{C.NC}"
    )
    print(
        f"    {C.MINT}info{C.NC}            {C.DIM}Show current status{C.NC}"
    )
    print(f"    {C.MINT}runs{C.NC}            {C.DIM}List all runs{C.NC}")
    print(f"    {C.MINT}show{C.NC}            {C.DIM}Show details of a run{C.NC}")
    print(
        f"    {C.MINT}milestone{C.NC}       {C.DIM}Manage milestones{C.NC}"
    )
    print(
        f"    {C.MINT}install{C.NC}         {C.DIM}Install ralph in a project{C.NC}"
    )
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Options:{C.NC}")
    print(
        f"    {C.MINT}-y, --yes{C.NC}       {C.DIM}Skip confirmation prompt (for run){C.NC}"
    )
    print(
        f"    {C.MINT}-s{C.NC}              {C.DIM}Skip all milestone verifications (for run){C.NC}"
    )
    print(
        f"    {C.MINT}--skip{C.NC}          {C.DIM}Mark milestone as skipped (for milestone <id>){C.NC}"
    )
    print(
        f"    {C.MINT}-n, --max{C.NC} N     {C.DIM}Max iterations (default: 20){C.NC}"
    )
    print(f"    {C.MINT}-h, --help{C.NC}      {C.DIM}Show this help{C.NC}")
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Examples:{C.NC}")
    print(f"    {C.SAGE}ralph{C.NC}                    {C.DIM}Show this help{C.NC}")
    print()
    print(f"  {C.DIM}Creating runs:{C.NC}")
    print(f"    {C.SAGE}ralph new \"Feature X\"{C.NC}    {C.DIM}Create a new run{C.NC}")
    print(f"    {C.SAGE}ralph add \"Task title\"{C.NC}   {C.DIM}Add task to current run{C.NC}")
    print(f"    {C.SAGE}ralph compile{C.NC}            {C.DIM}Add milestones{C.NC}")
    print()
    print(f"  {C.DIM}Executing:{C.NC}")
    print(f"    {C.SAGE}ralph run{C.NC}                {C.DIM}Execute tasks{C.NC}")
    print(f"    {C.SAGE}ralph run -y{C.NC}             {C.DIM}Skip confirmation{C.NC}")
    print(f"    {C.SAGE}ralph run -n 10{C.NC}          {C.DIM}Max 10 iterations{C.NC}")
    print()
    print(f"  {C.DIM}Status:{C.NC}")
    print(f"    {C.SAGE}ralph info{C.NC}               {C.DIM}Show current status{C.NC}")
    print(f"    {C.SAGE}ralph runs{C.NC}               {C.DIM}List all runs{C.NC}")
    print(f"    {C.SAGE}ralph show 1{C.NC}             {C.DIM}Show run details{C.NC}")
    print(f"    {C.SAGE}ralph milestone{C.NC}          {C.DIM}List milestones{C.NC}")
    print()


def main():
    if len(sys.argv) == 1 or sys.argv[1] in ("-h", "--help"):
        print_usage()
        sys.exit(0)

    parser = argparse.ArgumentParser(
        description="metrics-dsl Ralph Loop Runner",
        add_help=False,
    )

    parser.add_argument("command", nargs="?", default=None)
    parser.add_argument("subarg", nargs="?", default=None)  # For milestone <id>, show <run>
    parser.add_argument("subarg2", nargs="?", default=None)  # For milestone <id> <step>
    parser.add_argument("-y", "--yes", action="store_true")
    parser.add_argument("-s", "--skip-milestones", action="store_true", dest="skip_milestones")
    parser.add_argument("--skip", action="store_true")  # For milestone <id> --skip
    parser.add_argument("-n", "--max", type=int, default=20, dest="max_iterations")
    parser.add_argument("-h", "--help", action="store_true")
    parser.add_argument("--desc", type=str, default="")  # For add --desc
    parser.add_argument("--category", "-c", type=str, default="")  # For add --category
    parser.add_argument("--force", "-f", action="store_true")  # For compile --force
    parser.add_argument("--interval", "-i", type=int, default=5)  # For compile --interval
    parser.add_argument("--by-category", action="store_true", dest="by_category", default=True)
    parser.add_argument("--no-category", action="store_false", dest="by_category")

    args = parser.parse_args()

    if args.help:
        print_usage()
        sys.exit(0)

    project_dir = get_project_dir()
    project_name = project_dir.name
    prd_file = find_prd_file(project_dir)

    print_header(project_name)

    command = args.command

    if command == "install":
        # Install uses CWD, not detected project_dir (which requires .ralph/)
        target_dir = Path.cwd()
        print_header("Install")
        cmd_install(args, target_dir)
    elif command == "runs":
        cmd_runs(args, project_dir)
    elif command == "show":
        cmd_show(args, project_dir)
    elif command == "new":
        cmd_new(args, project_dir)
    elif command == "add":
        if not prd_file:
            print(f"  {C.CORAL}Error: No active PRD found{C.NC}")
            print(f"  {C.DIM}Create one with: ralph new \"Run Title\"{C.NC}")
            print()
            sys.exit(1)
        prd = load_prd(prd_file)
        cmd_add(args, project_dir, prd_file, prd)
    elif command == "compile":
        if not prd_file:
            print(f"  {C.CORAL}Error: No PRD file found{C.NC}")
            print(f"  {C.DIM}Create one with: ralph new \"Run Title\"{C.NC}")
            print()
            sys.exit(1)
        prd = load_prd(prd_file)
        cmd_compile(args, project_dir, prd_file, prd)
    elif command in ("run", "info", "milestone"):
        if not prd_file:
            print(f"  {C.CORAL}Error: No PRD file found{C.NC}")
            print(f"  {C.DIM}Looked for: .ralph/runs/run-*/prd.json (active){C.NC}")
            print()
            sys.exit(1)
        prd = load_prd(prd_file)
        if command == "run":
            cmd_run(args, project_dir, prd_file, prd)
        elif command == "milestone":
            cmd_milestone(args, project_dir, prd_file, prd, args.subarg, args.subarg2)
        else:
            cmd_info(args, project_dir, prd_file, prd)
    else:
        print_usage()
        sys.exit(0)


if __name__ == "__main__":
    main()
