#!/usr/bin/env python3
"""
Ralph Loop Runner - Development iteration system for Claude Code.

Runs Claude Code in fresh sessions to complete tasks from a PRD.
State is stored in .ralph/ directory of each project.

Usage:
    ralph run      - Execute PRD tasks
    ralph info     - Show current status
    ralph runs     - List all runs
"""

import argparse
import json
import os
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COLORS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class Colors:
    PINK = "\033[38;5;218m"
    LAVENDER = "\033[38;5;183m"
    MINT = "\033[38;5;158m"
    PEACH = "\033[38;5;216m"
    SKY = "\033[38;5;117m"
    CORAL = "\033[38;5;210m"
    SAGE = "\033[38;5;151m"
    YELLOW = "\033[38;5;221m"
    DIM = "\033[2m"
    BOLD = "\033[1m"
    NC = "\033[0m"


C = Colors

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HELPERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def get_project_dir():
    """Get project directory from current working directory.

    Walks up from CWD to find a directory containing .ralph/
    """
    cwd = Path.cwd()

    # Check CWD first
    if (cwd / ".ralph").is_dir():
        return cwd

    # Walk up to find .ralph/
    for parent in cwd.parents:
        if (parent / ".ralph").is_dir():
            return parent

    # Fallback to CWD
    return cwd


def find_prd_file(project_dir: Path) -> Path | None:
    """Find the active PRD file.

    Searches in order:
    1. .ralph/runs/run-NNN-*/prd.json with status "active" (newest first)
    2. Legacy locations: .ralph/prd-*.json, .ralph/prd.json, prd.json
    """
    runs_dir = project_dir / ".ralph" / "runs"

    # Check runs folder for active PRDs (newest run number first)
    if runs_dir.exists():
        run_dirs = sorted(
            [d for d in runs_dir.iterdir() if d.is_dir() and d.name.startswith("run-")],
            key=lambda d: d.name,
            reverse=True,
        )
        for run_dir in run_dirs:
            prd_file = run_dir / "prd.json"
            if prd_file.exists():
                try:
                    prd = load_prd(prd_file)
                    if prd.get("status") == "active":
                        return prd_file
                except (json.JSONDecodeError, OSError):
                    pass

    # Legacy fallback
    legacy_candidates = [
        project_dir / ".ralph" / "prd.json",
        project_dir / "prd.json",
    ]
    for candidate in legacy_candidates:
        if candidate.exists():
            return candidate
    return None


def get_run_dir(prd_file: Path) -> Path | None:
    """Get the run directory for a PRD file, if it's in a run folder."""
    if prd_file.parent.name.startswith("run-"):
        return prd_file.parent
    return None


def load_prd(prd_file: Path) -> dict:
    """Load PRD JSON file."""
    with open(prd_file) as f:
        return json.load(f)


def save_prd(prd_file: Path, prd: dict):
    """Save PRD JSON file."""
    with open(prd_file, "w") as f:
        json.dump(prd, f, indent=2)
        f.write("\n")


def get_prd_title(prd: dict) -> str:
    """Get PRD title."""
    return prd.get("title", "Untitled PRD")


def count_tasks_by_status(prd: dict) -> dict:
    """Count tasks by status."""
    counts = {"open": 0, "completed": 0, "total": 0}
    for story in prd.get("stories", []):
        status = story.get("status", "open")
        counts[status] = counts.get(status, 0) + 1
        counts["total"] += 1
    return counts


def get_completed_task_ids(prd: dict) -> set:
    """Get set of completed task IDs."""
    return {s["id"] for s in prd.get("stories", []) if s.get("status") == "completed"}


def deps_met(story: dict, completed_ids: set) -> bool:
    """Check if all dependencies are met."""
    for dep in story.get("dependencies", []):
        if dep not in completed_ids:
            return False
    return True


def get_open_tasks(prd: dict) -> list:
    """Get list of open tasks with dependency status."""
    completed_ids = get_completed_task_ids(prd)
    tasks = []
    for story in prd.get("stories", []):
        if story.get("status") == "open":
            ready = deps_met(story, completed_ids)
            tasks.append(
                {
                    "id": story["id"],
                    "title": story["title"],
                    "ready": ready,
                }
            )
    return tasks


def get_next_task(prd: dict) -> dict | None:
    """Get next available task (open with deps met)."""
    completed_ids = get_completed_task_ids(prd)
    for story in prd.get("stories", []):
        if story.get("status") == "open" and deps_met(story, completed_ids):
            return story
    return None


def is_milestone_task(task: dict) -> bool:
    """Check if a task is a milestone (requires manual verification)."""
    task_id = task.get("id", "")
    category = task.get("category", "")
    title = task.get("title", "").lower()
    return (
        task_id.startswith("M")
        or category == "milestone"
        or "milestone" in title
    )


def get_unverified_milestone(prd: dict) -> dict | None:
    """Get the first completed milestone that hasn't been verified by user.

    Returns the milestone task dict if found, None otherwise.
    """
    for story in prd.get("stories", []):
        if (
            story.get("status") == "completed"
            and is_milestone_task(story)
            and not story.get("verified", False)
        ):
            return story
    return None


def mark_milestone_verified(prd_file: Path, prd: dict, milestone_id: str):
    """Mark a milestone as verified in the PRD."""
    for story in prd.get("stories", []):
        if story["id"] == milestone_id:
            story["verified"] = True
            break
    save_prd(prd_file, prd)


def get_cycle_stage(project_dir: Path) -> str:
    """Get current cycle stage from CYCLE.md."""
    cycle_file = project_dir / ".ralph" / "CYCLE.md"
    if not cycle_file.exists():
        return "Unknown"

    content = cycle_file.read_text()
    for line in content.split("\n"):
        if "STAGE" in line and "â–¶" in line:
            stage = line.split("â–¶")[-1].strip()
            stage = stage.replace("â•‘", "").strip()
            return stage
    return "Unknown"


def run_command(cmd: list, cwd: Path | None = None, capture: bool = True) -> tuple:
    """Run a command and return (returncode, stdout, stderr)."""
    result = subprocess.run(
        cmd,
        cwd=cwd,
        capture_output=capture,
        text=True,
    )
    return result.returncode, result.stdout, result.stderr


def git_has_changes(project_dir: Path) -> bool:
    """Check if there are uncommitted changes."""
    run_command(["git", "add", "-A", "."], cwd=project_dir)
    code, _, _ = run_command(["git", "diff", "--staged", "--quiet"], cwd=project_dir)
    return code != 0


def git_commit(project_dir: Path, message: str):
    """Commit staged changes."""
    run_command(["git", "add", "-A", "."], cwd=project_dir)
    run_command(["git", "commit", "-m", message, "--quiet"], cwd=project_dir)


def git_rev_parse(project_dir: Path) -> str:
    """Get current commit hash."""
    code, stdout, _ = run_command(["git", "rev-parse", "HEAD"], cwd=project_dir)
    return stdout.strip() if code == 0 else "none"


def git_commit_count(project_dir: Path, from_hash: str, to_hash: str) -> int:
    """Count commits between two hashes."""
    code, stdout, _ = run_command(
        ["git", "rev-list", "--count", f"{from_hash}..{to_hash}"], cwd=project_dir
    )
    return int(stdout.strip()) if code == 0 else 0


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DISPLAY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def print_header(project_name: str = ""):
    """Print the Ralph header."""
    display_name = project_name or "Ralph"
    # Pad/truncate to fit the box (11 chars for project name area)
    display_name = display_name[:11].ljust(11)
    print()
    print(f"{C.SKY}  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”{C.NC}")
    print(
        f"{C.SKY}  â”‚{C.NC}     {C.PINK}{display_name}{C.NC} {C.DIM}~ Ralph Loop Runner{C.NC}                    {C.SKY}â”‚{C.NC}"
    )
    print(f"{C.SKY}  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜{C.NC}")
    print()


def print_task_list(tasks: list, indent: str = "  "):
    """Print list of tasks with status indicators."""
    for task in tasks:
        indicator = "â†’" if task["ready"] else "â¸"
        print(f"{indent}{indicator} {task['id']}: {task['title']}")


def print_completed_tasks(prd: dict, indent: str = "    "):
    """Print completed tasks."""
    for story in prd.get("stories", []):
        if story.get("status") == "completed":
            # Show verification status for milestones
            if is_milestone_task(story):
                if story.get("verified", False):
                    print(f"{indent}{C.MINT}âœ“{C.NC} {story['id']}: {story['title']} {C.MINT}[verified]{C.NC}")
                else:
                    print(f"{indent}{C.YELLOW}âš {C.NC} {story['id']}: {story['title']} {C.YELLOW}[needs verification]{C.NC}")
            else:
                print(f"{indent}âœ“ {story['id']}: {story['title']}")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COMMANDS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def get_ralph_implementation_dir() -> Path:
    """Get the directory where ralph's implementation lives."""
    # This script's actual location (resolving symlinks)
    return Path(__file__).resolve().parent


def verify_installation(target_dir: Path, ralph_impl_dir: Path) -> bool:
    """Verify an existing ralph installation and report/fix issues."""
    ralph_dir = target_dir / ".ralph"
    ralph_script = ralph_impl_dir / "ralph"
    issues = []
    fixed = []

    print(f"  {C.BOLD}{C.LAVENDER}Verifying Ralph Installation{C.NC}")
    print()
    print(f"  {C.DIM}Project:{C.NC}   {C.SAGE}{target_dir}{C.NC}")
    print(f"  {C.DIM}Ralph at:{C.NC}  {C.SAGE}{ralph_impl_dir}{C.NC}")
    print()

    # Check symlink
    symlink_path = ralph_dir / "ralph"
    if symlink_path.exists():
        if symlink_path.is_symlink():
            link_target = symlink_path.resolve()
            if link_target == ralph_script:
                print(f"  {C.MINT}âœ“{C.NC} Symlink correct: .ralph/ralph â†’ {ralph_script}")
            else:
                print(f"  {C.CORAL}âœ—{C.NC} Symlink points to wrong location: {link_target}")
                issues.append(("symlink_wrong", symlink_path, ralph_script))
        else:
            print(f"  {C.CORAL}âœ—{C.NC} .ralph/ralph is not a symlink (it's a regular file)")
            issues.append(("symlink_not_link", symlink_path, ralph_script))
    else:
        print(f"  {C.CORAL}âœ—{C.NC} Missing: .ralph/ralph symlink")
        issues.append(("symlink_missing", symlink_path, ralph_script))

    # Check required directories
    runs_dir = ralph_dir / "runs"
    if runs_dir.exists() and runs_dir.is_dir():
        print(f"  {C.MINT}âœ“{C.NC} Directory exists: .ralph/runs/")
    else:
        print(f"  {C.CORAL}âœ—{C.NC} Missing: .ralph/runs/ directory")
        issues.append(("dir_missing", runs_dir))

    # Check required files
    for filename in ("README.md", "CYCLE.md", "NOTES.md"):
        filepath = ralph_dir / filename
        if filepath.exists():
            print(f"  {C.MINT}âœ“{C.NC} File exists: .ralph/{filename}")
        else:
            print(f"  {C.YELLOW}â—‹{C.NC} Missing: .ralph/{filename}")
            issues.append(("file_missing", filepath, filename))

    print()

    if not issues:
        print(f"  {C.MINT}âœ“ Installation verified - everything looks good!{C.NC}")
        print()
        return True

    # Offer to fix issues
    print(f"  {C.YELLOW}Found {len(issues)} issue(s). Attempting to fix...{C.NC}")
    print()

    for issue in issues:
        issue_type = issue[0]

        if issue_type == "symlink_missing":
            symlink_path, target = issue[1], issue[2]
            symlink_path.symlink_to(target)
            print(f"  {C.MINT}âœ“{C.NC} Created symlink: .ralph/ralph")
            fixed.append(issue)

        elif issue_type == "symlink_wrong":
            symlink_path, target = issue[1], issue[2]
            symlink_path.unlink()
            symlink_path.symlink_to(target)
            print(f"  {C.MINT}âœ“{C.NC} Fixed symlink: .ralph/ralph")
            fixed.append(issue)

        elif issue_type == "symlink_not_link":
            symlink_path, target = issue[1], issue[2]
            # Backup the file first
            backup_path = symlink_path.with_suffix(".backup")
            symlink_path.rename(backup_path)
            symlink_path.symlink_to(target)
            print(f"  {C.MINT}âœ“{C.NC} Replaced file with symlink (backup: {backup_path.name})")
            fixed.append(issue)

        elif issue_type == "dir_missing":
            dir_path = issue[1]
            dir_path.mkdir(parents=True)
            print(f"  {C.MINT}âœ“{C.NC} Created directory: {dir_path.relative_to(target_dir)}")
            fixed.append(issue)

        elif issue_type == "file_missing":
            # Don't auto-create content files - just warn
            filepath, filename = issue[1], issue[2]
            print(f"  {C.DIM}â—‹{C.NC} Skipped: .ralph/{filename} (create manually or reinstall)")

    print()

    unfixed = len(issues) - len(fixed)
    if unfixed == 0:
        print(f"  {C.MINT}âœ“ All issues fixed!{C.NC}")
    else:
        print(f"  {C.YELLOW}â—‹ {unfixed} issue(s) need manual attention{C.NC}")

    print()
    return unfixed == 0


def cmd_install(args, target_dir: Path):
    """Install ralph in a new project directory, or verify existing installation."""
    ralph_impl_dir = get_ralph_implementation_dir()
    ralph_script = ralph_impl_dir / "ralph"
    ralph_dir = target_dir / ".ralph"

    # If already installed, verify the installation
    if ralph_dir.exists():
        return verify_installation(target_dir, ralph_impl_dir)

    print(f"  {C.BOLD}{C.LAVENDER}Installing Ralph{C.NC}")
    print()
    print(f"  {C.DIM}Target:{C.NC}    {C.SAGE}{target_dir}{C.NC}")
    print(f"  {C.DIM}Ralph at:{C.NC}  {C.SAGE}{ralph_impl_dir}{C.NC}")
    print()

    # Create directory structure
    ralph_dir.mkdir(parents=True)
    (ralph_dir / "runs").mkdir()

    # Create symlink to ralph script
    symlink_path = ralph_dir / "ralph"
    symlink_path.symlink_to(ralph_script)
    print(f"  {C.MINT}âœ“{C.NC} Created symlink: .ralph/ralph")

    # Create README.md
    readme_content = f"""# Ralph - Development Loop Runner

This project uses **Ralph**, a development iteration system for Claude Code.

## Quick Start

```bash
.ralph/ralph run      # Execute PRD tasks
.ralph/ralph info     # Show current status
.ralph/ralph runs     # List all runs
```

## How It Works

Ralph runs Claude Code in fresh sessions to complete tasks from a PRD (Product Requirements Document).

1. **Create a PRD** in `.ralph/runs/run-NNN-description/prd.json`
2. **Run Ralph** with `.ralph/ralph run`
3. **Claude works** on one task per iteration
4. **Ralph commits** changes and moves to next task
5. **Milestones pause** for manual verification

## Directory Structure

```
.ralph/
â”œâ”€â”€ ralph          â†’ Symlink to central implementation
â”œâ”€â”€ README.md      â†’ This file
â”œâ”€â”€ CYCLE.md       â†’ Current development stage
â”œâ”€â”€ NOTES.md       â†’ User constraints & project context
â””â”€â”€ runs/          â†’ PRD runs
    â””â”€â”€ run-001-*/
        â”œâ”€â”€ prd.json      â†’ Task definitions
        â””â”€â”€ progress.txt  â†’ Execution log
```

## Important: Making Changes to Ralph

**DO NOT modify the ralph script in this repo.**

The `ralph` file in `.ralph/` is a symlink to the central implementation.
To find where Ralph lives, check the symlink:

```bash
ls -la .ralph/ralph
```

If you want to improve or fix Ralph:
1. Follow the symlink to find the implementation repo
2. Make your changes there
3. All projects using Ralph will get the updates

This keeps Ralph consistent across all projects and makes updates easy.

## PRD Format

PRDs are JSON files with this structure:

```json
{{
  "title": "Project Name",
  "status": "active",
  "stories": [
    {{
      "id": "001",
      "title": "Task title",
      "description": "What to do",
      "status": "open",
      "dependencies": []
    }},
    {{
      "id": "M1",
      "title": "Milestone: Review Progress",
      "category": "milestone",
      "status": "open",
      "dependencies": ["001"]
    }}
  ]
}}
```

- Task IDs starting with `M` are milestones (require manual verification)
- Dependencies must be completed before a task becomes available
- Status: `open` â†’ `completed`

## Tips

- Read `NOTES.md` before starting - it contains important constraints
- Check `CYCLE.md` to know what development stage you're in
- Milestones pause execution for human review
- Run `ralph info` to see current progress

---

*Check `.ralph/ralph` symlink to find Ralph's implementation repo*
"""
    (ralph_dir / "README.md").write_text(readme_content)
    print(f"  {C.MINT}âœ“{C.NC} Created README.md")

    # Create CYCLE.md
    cycle_content = """# Development Cycle

Current stage in the development cycle.

## Stages

```
â•‘ 1. DISCUSS & MAP    â†’ Talk with user, explore problems
â•‘ 2. DESIGN PRD       â†’ Convert discussion into structured tasks
â–¶ 3. EXECUTE PRD      â†’ Run ralph loop, complete tasks
â•‘ 4. EVALUATE         â†’ Test, review, document learnings
â•‘ 5. NEW CYCLE        â†’ Archive and start fresh
```

---

*Update the arrow (â–¶) to indicate current stage*
"""
    (ralph_dir / "CYCLE.md").write_text(cycle_content)
    print(f"  {C.MINT}âœ“{C.NC} Created CYCLE.md")

    # Create NOTES.md
    notes_content = """# User Notes & Directives

**This file contains important context for Claude. Read before each iteration.**

---

## Project Context

*(Describe what this project is and what you're trying to accomplish)*

---

## User Requirements

*(Add specific requirements, constraints, and preferences here)*

---

## Technical Decisions

*(Document important technical decisions and their rationale)*

---

## Constraints (Don't Do These)

*(List things that should NOT be done)*

---

## Learnings & Insights

*(Update as project progresses)*

---

*Last updated: (date)*
"""
    (ralph_dir / "NOTES.md").write_text(notes_content)
    print(f"  {C.MINT}âœ“{C.NC} Created NOTES.md")

    print()
    print(f"  {C.MINT}âœ“ Ralph installed successfully!{C.NC}")
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Next steps:{C.NC}")
    print(f"    1. Edit {C.SAGE}.ralph/NOTES.md{C.NC} with project context")
    print(f"    2. Create a PRD in {C.SAGE}.ralph/runs/run-001-description/prd.json{C.NC}")
    print(f"    3. Run {C.SAGE}.ralph/ralph run{C.NC} to start")
    print()

    return True


def cmd_runs(args, project_dir: Path):
    """List all runs."""
    runs_dir = project_dir / ".ralph" / "runs"

    if not runs_dir.exists() or not any(runs_dir.iterdir()):
        print(f"  {C.DIM}No runs found{C.NC}")
        print()
        return

    print(f"  {C.BOLD}{C.LAVENDER}All Runs{C.NC}")
    print()

    run_dirs = sorted(
        [d for d in runs_dir.iterdir() if d.is_dir() and d.name.startswith("run-")],
        key=lambda d: d.name,
    )

    for i, run_dir in enumerate(run_dirs, 1):
        prd_file = run_dir / "prd.json"
        if prd_file.exists():
            try:
                run_prd = load_prd(prd_file)
                status = run_prd.get("status", "unknown")
                title = run_prd.get("title", "Untitled")
                counts = count_tasks_by_status(run_prd)

                if status == "active":
                    indicator = f"{C.MINT}â— active{C.NC}"
                elif status == "completed":
                    indicator = f"{C.SAGE}âœ“ done{C.NC}"
                else:
                    indicator = f"{C.DIM}â—‹ {status}{C.NC}"

                print(f"  {C.PINK}{i}{C.NC}  {C.SKY}{run_dir.name}{C.NC}  {indicator}")
                print(f"       {C.SAGE}{title}{C.NC}")
                print(
                    f"       {C.DIM}{counts['completed']}/{counts['total']} tasks completed{C.NC}"
                )
                print()
            except Exception:
                print(
                    f"  {C.PINK}{i}{C.NC}  {C.SKY}{run_dir.name}{C.NC}  {C.CORAL}(error reading PRD){C.NC}"
                )
                print()

    print(
        f"  {C.DIM}View details:{C.NC} {C.SAGE}ralph show <index|name>{C.NC}"
    )
    print()


def cmd_info(args, project_dir: Path, prd_file: Path, prd: dict):
    """Show current cycle status and PRD details."""
    counts = count_tasks_by_status(prd)

    print(f"  {C.BOLD}{C.LAVENDER}Current Cycle{C.NC}")
    print()

    stage = get_cycle_stage(project_dir)
    print(f"  {C.DIM}Stage{C.NC}         {C.MINT}{stage}{C.NC}")
    print(f"  {C.DIM}PRD{C.NC}           {C.SAGE}{get_prd_title(prd)}{C.NC}")
    print(
        f"  {C.DIM}File{C.NC}          {C.SAGE}{prd_file.relative_to(project_dir)}{C.NC}"
    )
    print(
        f"  {C.DIM}Progress{C.NC}      {C.SAGE}{counts['completed']}{C.NC}{C.DIM}/{C.NC}{C.SAGE}{counts['total']}{C.NC} {C.DIM}tasks completed{C.NC}"
    )
    print()

    print(f"  {C.BOLD}{C.LAVENDER}Tasks{C.NC}")
    print()

    if counts["completed"] > 0:
        print(f"  {C.DIM}Completed:{C.NC}")
        print_completed_tasks(prd)
        print()

    open_tasks = get_open_tasks(prd)
    if open_tasks:
        ready_count = sum(1 for t in open_tasks if t["ready"])
        print(
            f"  {C.DIM}Open:{C.NC} {C.DIM}({ready_count} ready, {len(open_tasks) - ready_count} blocked){C.NC}"
        )
        for task in open_tasks:
            indicator = "â†’" if task["ready"] else "â¸"
            print(f"    {indicator} {task['id']}: {task['title']}")
        print()

    notes_file = project_dir / ".ralph" / "NOTES.md"
    if notes_file.exists():
        print(f"  {C.DIM}See notes:{C.NC} {C.SAGE}cat .ralph/NOTES.md{C.NC}")
        print()


def cmd_run(args, project_dir: Path, prd_file: Path, prd: dict):
    """Run the Ralph loop."""
    counts = count_tasks_by_status(prd)
    open_tasks = get_open_tasks(prd)
    next_task = get_next_task(prd)

    print(f"  {C.BOLD}{C.LAVENDER}PRD:{C.NC} {C.SAGE}{get_prd_title(prd)}{C.NC}")
    print(f"  {C.DIM}File:{C.NC} {C.SAGE}{prd_file.relative_to(project_dir)}{C.NC}")
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Configuration:{C.NC}")
    print(f"  {C.DIM}Project{C.NC}       {C.SAGE}{project_dir}{C.NC}")
    print(f"  {C.DIM}Max iters{C.NC}     {C.SAGE}{args.max_iterations}{C.NC}")
    print(f"  {C.DIM}Tasks open{C.NC}    {C.SAGE}{counts['open']}{C.NC}")
    print()

    if counts["open"] == 0:
        print(f"  {C.MINT}âœ“ All tasks already complete!{C.NC}")
        print()
        return

    ready_tasks = [t for t in open_tasks if t["ready"]]
    print(
        f"  {C.BOLD}{C.LAVENDER}Ready Tasks:{C.NC} {C.DIM}({len(ready_tasks)} ready to execute){C.NC}"
    )
    for task in ready_tasks[:5]:
        print(f"    â†’ {task['id']}: {task['title']}")
    if len(ready_tasks) > 5:
        print(f"    {C.DIM}... and {len(ready_tasks) - 5} more{C.NC}")
    print()

    if next_task:
        print(f"  {C.BOLD}{C.YELLOW}First task to execute:{C.NC}")
        print(f"  {C.MINT}â–¸ {next_task['id']}{C.NC} {C.SAGE}{next_task['title']}{C.NC}")
        print()
    else:
        print(f"  {C.CORAL}âœ— No tasks available (check dependencies){C.NC}")
        print()
        return

    # Check for unverified milestones BEFORE asking to proceed
    unverified = get_unverified_milestone(prd)
    if unverified:
        print(
            f"  {C.SKY}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{C.NC}"
        )
        print()
        print(f"  {C.YELLOW}{C.BOLD}ğŸ›‘ UNVERIFIED MILESTONE: {unverified['id']}{C.NC}")
        print(f"  {C.SAGE}{unverified['title']}{C.NC}")
        print()
        print(f"  {C.DIM}This milestone was completed but not yet verified.{C.NC}")
        print(f"  {C.DIM}Please review before continuing.{C.NC}")
        print()
        print(f"  {C.MINT}Milestone description:{C.NC}")
        # Show first few lines of description
        desc_lines = unverified.get("description", "").split("\\n")[:15]
        for line in desc_lines:
            print(f"  {C.DIM}{line}{C.NC}")
        if len(unverified.get("description", "").split("\\n")) > 15:
            print(f"  {C.DIM}...{C.NC}")
        print()
        print(f"  {C.MINT}To view full details:{C.NC}")
        print(
            f"    {C.SAGE}cat {prd_file.relative_to(project_dir)} | grep -A 100 '\"id\": \"{unverified['id']}\"'{C.NC}"
        )
        print()
        print(
            f"  {C.SKY}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{C.NC}"
        )
        print()
        try:
            reply = input(
                f"  {C.YELLOW}Mark milestone {unverified['id']} as verified and continue? [y/N]{C.NC} "
            ).strip().lower()
        except (KeyboardInterrupt, EOFError):
            print()
            print()
            print(
                f"  {C.PEACH}Paused. Verify milestone and run '.ralph/ralph run' to continue.{C.NC}"
            )
            print()
            return

        if reply not in ("y", "yes"):
            print()
            print(
                f"  {C.PEACH}Paused. Verify milestone and run '.ralph/ralph run' to continue.{C.NC}"
            )
            print()
            return

        # Mark milestone as verified
        mark_milestone_verified(prd_file, prd, unverified["id"])
        print()
        print(f"  {C.MINT}âœ“ Milestone {unverified['id']} marked as verified{C.NC}")
        print()

        # Check if there are more unverified milestones
        prd = load_prd(prd_file)
        next_unverified = get_unverified_milestone(prd)
        if next_unverified:
            print(
                f"  {C.PEACH}Note: There are more unverified milestones. Run again to verify.{C.NC}"
            )
            print()
            return

    # Now ask to proceed (after milestone check)
    if not args.yes:
        print(
            f"  {C.SKY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€{C.NC}"
        )
        print()
        print(f"  {C.YELLOW}Ready to start Ralph loop.{C.NC}")
        print(
            f"  {C.DIM}This will run Claude Code up to {args.max_iterations} times.{C.NC}"
        )
        print()

        try:
            reply = input("  Proceed? [y/N] ").strip().lower()
        except (KeyboardInterrupt, EOFError):
            print()
            print()
            print(f"  {C.PEACH}Cancelled.{C.NC}")
            print()
            return

        print()

        if reply not in ("y", "yes"):
            print(f"  {C.PEACH}Cancelled.{C.NC}")
            print()
            return

    # Setup
    run_dir = get_run_dir(prd_file)
    if run_dir:
        progress_file = run_dir / "progress.txt"
    else:
        progress_file = project_dir / ".ralph" / "progress.txt"
    notes_file = project_dir / ".ralph" / "NOTES.md"

    # Commit any uncommitted changes
    if git_has_changes(project_dir):
        print(f"  {C.PEACH}Found uncommitted changes from previous run{C.NC}")
        git_commit(
            project_dir,
            "[ralph] Recover uncommitted changes from previous run\n\n"
            "Co-Authored-By: Claude <noreply@anthropic.com>",
        )
        print(f"  {C.MINT}âœ“ Previous changes committed{C.NC}")
        print()

    # Main loop
    for i in range(1, args.max_iterations + 1):
        prd = load_prd(prd_file)
        counts = count_tasks_by_status(prd)
        next_task = get_next_task(prd)

        print(
            f"  {C.SKY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€{C.NC}"
        )
        print()
        print(
            f"  {C.LAVENDER}Iteration {C.PINK}{i}{C.LAVENDER} of {C.PINK}{args.max_iterations}{C.NC}    {C.DIM}remaining: {counts['open']} tasks{C.NC}"
        )

        if counts["open"] == 0:
            print(f"  {C.MINT}âœ“ All tasks complete{C.NC}")
            print()
            break

        if not next_task:
            print(f"  {C.CORAL}âœ— No available tasks (check dependencies){C.NC}")
            print()
            break

        print(f"  {C.MINT}â–¸ {next_task['id']}{C.NC} {C.SAGE}{next_task['title']}{C.NC}")
        print()

        start_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        commit_before = git_rev_parse(project_dir)

        prd_title = get_prd_title(prd)
        prompt = f"""You are working on a development project managed by Ralph.

## Project: {project_dir.name}
## PRD: {prd_title}

## Instructions

1. Read the PRD file: {prd_file}
2. Read progress file: {progress_file}
3. Read notes file: {notes_file} (important user constraints and project context!)
4. Find the FIRST task with status "open" whose dependencies are all "completed"
5. Work on that ONE task completely
6. When done:
   - Update the PRD: change the task's status from "open" to "completed"
   - Append to progress.txt what you did, including:
     - Task ID and title
     - What was accomplished
     - Any files created/modified
     - Any issues encountered
   - Make sure all your work is saved to files

## Important Rules

- Complete ONE task per iteration, then stop
- Read NOTES.md for user constraints and project context
- Create all necessary directories and files
- Write working, tested code
- Update both the PRD AND progress.txt before finishing
- If a task cannot be completed, document why in progress.txt and move on
- MILESTONE tasks (IDs starting with M): These are verification checkpoints.
  Mark them complete after documenting in progress.txt what was built and
  noting that manual verification is recommended.

Start by reading the PRD, progress, and notes files, then work on the next available task.
"""

        print(f"  {C.DIM}Claude is working on task {next_task['id']}...{C.NC}")

        subprocess.run(
            ["claude", "--print", "--dangerously-skip-permissions", str(project_dir)],
            input=prompt,
            capture_output=True,
            text=True,
        )

        end_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"  {C.DIM}Completed at {end_time}{C.NC}")
        print()

        commit_after = git_rev_parse(project_dir)

        if commit_before != commit_after and commit_before != "none":
            commits_made = git_commit_count(project_dir, commit_before, commit_after)
            print(f"  {C.MINT}âœ“ Claude made {commits_made} commit(s){C.NC}")

        if git_has_changes(project_dir):
            git_commit(
                project_dir,
                f"[ralph] Iteration {i}: {next_task['title']}\n\n"
                f"Task: {next_task['id']}\n"
                f"Time: {start_time} - {end_time}\n\n"
                "Co-Authored-By: Claude <noreply@anthropic.com>",
            )
            print(f"  {C.MINT}âœ“ Additional changes committed{C.NC}")
        elif commit_before == commit_after:
            print(f"  {C.PEACH}â—‹ No changes{C.NC}")

        print()

        # Check if we just completed a milestone - pause for manual verification
        prd = load_prd(prd_file)
        task_now = next((s for s in prd.get("stories", []) if s["id"] == next_task["id"]), None)
        if task_now and task_now.get("status") == "completed" and is_milestone_task(next_task):
            print(
                f"  {C.SKY}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{C.NC}"
            )
            print()
            print(f"  {C.YELLOW}{C.BOLD}ğŸ›‘ MILESTONE REACHED: {next_task['id']}{C.NC}")
            print(f"  {C.SAGE}{next_task['title']}{C.NC}")
            print()
            print(f"  {C.DIM}Ralph has paused for manual verification.{C.NC}")
            print(f"  {C.DIM}Review the milestone and run '.ralph/ralph run' when ready.{C.NC}")
            print()
            print(f"  {C.MINT}To view milestone details:{C.NC}")
            print(f"    {C.SAGE}cat {prd_file.relative_to(project_dir)} | grep -A 100 '\"id\": \"{next_task['id']}\"'{C.NC}")
            print()
            print(
                f"  {C.SKY}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{C.NC}"
            )
            print()
            # Don't prompt here - user will run ralph again and be prompted to verify
            return

        time.sleep(1)

    prd = load_prd(prd_file)
    counts = count_tasks_by_status(prd)

    print(f"  {C.SKY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€{C.NC}")
    print()
    print(f"  {C.LAVENDER}Loop complete{C.NC}")
    print(
        f"  {C.DIM}Iterations:{C.NC} {C.SAGE}{i}{C.NC}    {C.DIM}Remaining:{C.NC} {C.SAGE}{counts['open']}{C.NC}"
    )
    print()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def print_usage():
    """Print colorful usage information."""
    project_dir = get_project_dir()
    project_name = project_dir.name
    has_ralph = (project_dir / ".ralph").is_dir()

    print()
    print(f"{C.SKY}  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”{C.NC}")
    print(
        f"{C.SKY}  â”‚{C.NC}     {C.PINK}Ralph{C.NC}       {C.DIM}~ Development Loop Runner{C.NC}              {C.SKY}â”‚{C.NC}"
    )
    print(f"{C.SKY}  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜{C.NC}")
    print()
    if has_ralph:
        print(f"  {C.BOLD}{C.LAVENDER}Project:{C.NC} {C.MINT}{project_name}{C.NC}")
        print(f"  {C.DIM}Path:{C.NC}    {C.SAGE}{project_dir}{C.NC}")
        print()
    else:
        print(f"  {C.CORAL}No .ralph/ directory found in current path{C.NC}")
        print(f"  {C.DIM}CWD: {project_dir}{C.NC}")
        print()
    print(
        f"  {C.BOLD}{C.LAVENDER}Usage:{C.NC} ralph {C.DIM}[command] [options]{C.NC}"
    )
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Commands:{C.NC}")
    print(
        f"    {C.MINT}run{C.NC}             {C.DIM}Run the iteration loop (execute PRD tasks){C.NC}"
    )
    print(
        f"    {C.MINT}info{C.NC}            {C.DIM}Show current cycle status and PRD details{C.NC}"
    )
    print(f"    {C.MINT}runs{C.NC}            {C.DIM}List all runs{C.NC}")
    print(
        f"    {C.MINT}install{C.NC}         {C.DIM}Install ralph in current directory{C.NC}"
    )
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Options:{C.NC}")
    print(
        f"    {C.MINT}-y, --yes{C.NC}       {C.DIM}Skip confirmation prompt (for run){C.NC}"
    )
    print(
        f"    {C.MINT}-n, --max{C.NC} N     {C.DIM}Max iterations (default: 20){C.NC}"
    )
    print(f"    {C.MINT}-h, --help{C.NC}      {C.DIM}Show this help{C.NC}")
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Examples:{C.NC}")
    print(f"    {C.SAGE}ralph{C.NC}              {C.DIM}Show this help{C.NC}")
    print(
        f"    {C.SAGE}ralph run{C.NC}          {C.DIM}Run the iteration loop{C.NC}"
    )
    print(
        f"    {C.SAGE}ralph run -y{C.NC}       {C.DIM}Run without confirmation{C.NC}"
    )
    print(
        f"    {C.SAGE}ralph run -n 10{C.NC}    {C.DIM}Run up to 10 iterations{C.NC}"
    )
    print(
        f"    {C.SAGE}ralph info{C.NC}         {C.DIM}Show current status{C.NC}"
    )
    print(f"    {C.SAGE}ralph runs{C.NC}         {C.DIM}List all runs{C.NC}")
    print(f"    {C.SAGE}ralph install{C.NC}      {C.DIM}Install ralph in current dir{C.NC}")
    print()


def main():
    if len(sys.argv) == 1 or sys.argv[1] in ("-h", "--help"):
        print_usage()
        sys.exit(0)

    parser = argparse.ArgumentParser(
        description="metrics-dsl Ralph Loop Runner",
        add_help=False,
    )

    parser.add_argument("command", nargs="?", default=None)
    parser.add_argument("-y", "--yes", action="store_true")
    parser.add_argument("-n", "--max", type=int, default=20, dest="max_iterations")
    parser.add_argument("-h", "--help", action="store_true")

    args = parser.parse_args()

    if args.help:
        print_usage()
        sys.exit(0)

    project_dir = get_project_dir()
    project_name = project_dir.name
    prd_file = find_prd_file(project_dir)

    print_header(project_name)

    command = args.command

    if command == "install":
        # Install uses CWD, not detected project_dir (which requires .ralph/)
        target_dir = Path.cwd()
        print_header("Install")
        cmd_install(args, target_dir)
    elif command == "runs":
        cmd_runs(args, project_dir)
    elif command in ("run", "info"):
        if not prd_file:
            print(f"  {C.CORAL}Error: No PRD file found{C.NC}")
            print(f"  {C.DIM}Looked for: .ralph/runs/run-*/prd.json (active){C.NC}")
            print()
            sys.exit(1)
        prd = load_prd(prd_file)
        if command == "run":
            cmd_run(args, project_dir, prd_file, prd)
        else:
            cmd_info(args, project_dir, prd_file, prd)
    else:
        print_usage()
        sys.exit(0)


if __name__ == "__main__":
    main()
