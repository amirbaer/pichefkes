#!/usr/bin/env python3
"""
Ralph Loop Runner - Development iteration system for Claude Code.

Runs Claude Code in fresh sessions to complete tasks from a PRD.
State is stored in .ralph/ directory of each project.

Usage:
    ralph run      - Execute PRD tasks
    ralph info     - Show current status
    ralph runs     - List all runs
"""

import argparse
import json
import os
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path

# ═══════════════════════════════════════════════════════════════════
# COLORS
# ═══════════════════════════════════════════════════════════════════


class Colors:
    PINK = "\033[38;5;218m"
    LAVENDER = "\033[38;5;183m"
    MINT = "\033[38;5;158m"
    PEACH = "\033[38;5;216m"
    SKY = "\033[38;5;117m"
    CORAL = "\033[38;5;210m"
    SAGE = "\033[38;5;151m"
    YELLOW = "\033[38;5;221m"
    DIM = "\033[2m"
    BOLD = "\033[1m"
    NC = "\033[0m"


C = Colors

# ═══════════════════════════════════════════════════════════════════
# HELPERS
# ═══════════════════════════════════════════════════════════════════


def get_project_dir():
    """Get project directory from current working directory.

    Walks up from CWD to find a directory containing .ralph/
    """
    cwd = Path.cwd()

    # Check CWD first
    if (cwd / ".ralph").is_dir():
        return cwd

    # Walk up to find .ralph/
    for parent in cwd.parents:
        if (parent / ".ralph").is_dir():
            return parent

    # Fallback to CWD
    return cwd


def find_prd_file(project_dir: Path) -> Path | None:
    """Find the active PRD file.

    Searches in order:
    1. .ralph/runs/run-NNN-*/prd.json with status "active" (newest first)
    2. Legacy locations: .ralph/prd-*.json, .ralph/prd.json, prd.json
    """
    runs_dir = project_dir / ".ralph" / "runs"

    # Check runs folder for active PRDs (newest run number first)
    if runs_dir.exists():
        run_dirs = sorted(
            [d for d in runs_dir.iterdir() if d.is_dir() and d.name.startswith("run-")],
            key=lambda d: d.name,
            reverse=True,
        )
        for run_dir in run_dirs:
            prd_file = run_dir / "prd.json"
            if prd_file.exists():
                try:
                    prd = load_prd(prd_file)
                    if prd.get("status") == "active":
                        return prd_file
                except (json.JSONDecodeError, OSError):
                    pass

    # Legacy fallback
    legacy_candidates = [
        project_dir / ".ralph" / "prd.json",
        project_dir / "prd.json",
    ]
    for candidate in legacy_candidates:
        if candidate.exists():
            return candidate
    return None


def get_run_dir(prd_file: Path) -> Path | None:
    """Get the run directory for a PRD file, if it's in a run folder."""
    if prd_file.parent.name.startswith("run-"):
        return prd_file.parent
    return None


def load_prd(prd_file: Path) -> dict:
    """Load PRD JSON file."""
    with open(prd_file) as f:
        return json.load(f)


def save_prd(prd_file: Path, prd: dict):
    """Save PRD JSON file."""
    with open(prd_file, "w") as f:
        json.dump(prd, f, indent=2)
        f.write("\n")


def get_prd_title(prd: dict) -> str:
    """Get PRD title."""
    return prd.get("title", "Untitled PRD")


def count_tasks_by_status(prd: dict) -> dict:
    """Count tasks by status."""
    counts = {"open": 0, "completed": 0, "total": 0}
    for story in prd.get("stories", []):
        status = story.get("status", "open")
        counts[status] = counts.get(status, 0) + 1
        counts["total"] += 1
    return counts


def get_completed_task_ids(prd: dict) -> set:
    """Get set of completed task IDs."""
    return {s["id"] for s in prd.get("stories", []) if s.get("status") == "completed"}


def deps_met(story: dict, completed_ids: set) -> bool:
    """Check if all dependencies are met."""
    for dep in story.get("dependencies", []):
        if dep not in completed_ids:
            return False
    return True


def get_open_tasks(prd: dict) -> list:
    """Get list of open tasks with dependency status."""
    completed_ids = get_completed_task_ids(prd)
    tasks = []
    for story in prd.get("stories", []):
        if story.get("status") == "open":
            ready = deps_met(story, completed_ids)
            tasks.append(
                {
                    "id": story["id"],
                    "title": story["title"],
                    "ready": ready,
                }
            )
    return tasks


def get_next_task(prd: dict) -> dict | None:
    """Get next available task (open with deps met)."""
    completed_ids = get_completed_task_ids(prd)
    for story in prd.get("stories", []):
        if story.get("status") == "open" and deps_met(story, completed_ids):
            return story
    return None


def is_milestone_task(task: dict) -> bool:
    """Check if a task is a milestone (requires manual verification)."""
    task_id = task.get("id", "")
    category = task.get("category", "")
    title = task.get("title", "").lower()
    return (
        task_id.startswith("M")
        or category == "milestone"
        or "milestone" in title
    )


def get_unverified_milestone(prd: dict) -> dict | None:
    """Get the first completed milestone that hasn't been verified or skipped.

    Returns the milestone task dict if found, None otherwise.
    """
    for story in prd.get("stories", []):
        if (
            story.get("status") == "completed"
            and is_milestone_task(story)
            and not story.get("verified", False)
            and not story.get("skipped", False)
        ):
            return story
    return None


def mark_milestone_verified(prd_file: Path, prd: dict, milestone_id: str):
    """Mark a milestone as verified in the PRD."""
    for story in prd.get("stories", []):
        if story["id"] == milestone_id:
            story["verified"] = True
            break
    save_prd(prd_file, prd)


def mark_milestone_skipped(prd_file: Path, prd: dict, milestone_id: str):
    """Mark a milestone as skipped in the PRD."""
    for story in prd.get("stories", []):
        if story["id"] == milestone_id:
            story["skipped"] = True
            break
    save_prd(prd_file, prd)


def get_cycle_stage(project_dir: Path) -> str:
    """Get current cycle stage from CYCLE.md."""
    cycle_file = project_dir / ".ralph" / "CYCLE.md"
    if not cycle_file.exists():
        return "Unknown"

    content = cycle_file.read_text()
    for line in content.split("\n"):
        if "STAGE" in line and "▶" in line:
            stage = line.split("▶")[-1].strip()
            stage = stage.replace("║", "").strip()
            return stage
    return "Unknown"


def run_command(cmd: list, cwd: Path | None = None, capture: bool = True) -> tuple:
    """Run a command and return (returncode, stdout, stderr)."""
    result = subprocess.run(
        cmd,
        cwd=cwd,
        capture_output=capture,
        text=True,
    )
    return result.returncode, result.stdout, result.stderr


def git_has_changes(project_dir: Path) -> bool:
    """Check if there are uncommitted changes."""
    run_command(["git", "add", "-A", "."], cwd=project_dir)
    code, _, _ = run_command(["git", "diff", "--staged", "--quiet"], cwd=project_dir)
    return code != 0


def git_commit(project_dir: Path, message: str):
    """Commit staged changes."""
    run_command(["git", "add", "-A", "."], cwd=project_dir)
    run_command(["git", "commit", "-m", message, "--quiet"], cwd=project_dir)


def git_rev_parse(project_dir: Path) -> str:
    """Get current commit hash."""
    code, stdout, _ = run_command(["git", "rev-parse", "HEAD"], cwd=project_dir)
    return stdout.strip() if code == 0 else "none"


def git_commit_count(project_dir: Path, from_hash: str, to_hash: str) -> int:
    """Count commits between two hashes."""
    code, stdout, _ = run_command(
        ["git", "rev-list", "--count", f"{from_hash}..{to_hash}"], cwd=project_dir
    )
    return int(stdout.strip()) if code == 0 else 0


# ═══════════════════════════════════════════════════════════════════
# MILESTONE VALIDATION
# ═══════════════════════════════════════════════════════════════════


def extract_code_blocks(description: str) -> list:
    """Extract code blocks from milestone description.

    Returns list of dicts with 'lang', 'title', and 'commands' keys.
    """
    import re

    # Handle JSON escaped newlines
    description = description.replace("\\n", "\n")

    blocks = []

    # Find code blocks with their preceding section titles
    # Look for ## Title followed by ```lang ... ```
    pattern = r'## ([^\n]+)\n```(\w*)\n(.*?)```'

    for match in re.finditer(pattern, description, re.DOTALL):
        title = match.group(1).strip()
        lang = match.group(2) or "bash"
        code = match.group(3).strip()

        if lang in ("bash", "sh", "shell", ""):
            # Parse commands, handling multi-line strings
            commands = []
            lines = code.split("\n")
            i = 0
            while i < len(lines):
                line = lines[i]
                stripped = line.strip()

                # Skip empty lines and comments
                if not stripped or stripped.startswith("#"):
                    i += 1
                    continue

                # Check if line starts a multi-line python -c command
                # These start with python3 -c " and end with a line that has just "
                if ('python3 -c "' in stripped or 'python -c "' in stripped) and not stripped.endswith('""'):
                    # Collect lines until closing quote (line ending with just ")
                    multi_line = [line]
                    i += 1
                    while i < len(lines):
                        next_line = lines[i]
                        multi_line.append(next_line)
                        # Check if this line ends the multi-line command
                        if next_line.strip() == '"' or next_line.strip().endswith('"'):
                            i += 1
                            break
                        i += 1
                    # Join as single command
                    commands.append("\n".join(multi_line))
                else:
                    commands.append(stripped)
                    i += 1

            if commands:
                blocks.append({
                    "title": title,
                    "lang": lang,
                    "commands": commands,
                })

    return blocks


def run_milestone_validation(project_dir: Path, milestone: dict) -> tuple:
    """Run validation commands from milestone description.

    Returns (passed: int, failed: int, results: list)
    """
    description = milestone.get("description", "")
    blocks = extract_code_blocks(description)

    if not blocks:
        return 0, 0, []

    results = []
    passed = 0
    failed = 0

    print(f"  {C.BOLD}{C.LAVENDER}Running Milestone Validation{C.NC}")
    print()

    # Track current directory for cd commands
    cwd = project_dir

    for block in blocks:
        title = block["title"]
        commands = block["commands"]

        print(f"  {C.YELLOW}▸{C.NC} {C.SAGE}{title}{C.NC}")

        block_passed = True
        for cmd in commands:
            # Handle cd commands specially - update cwd for subsequent commands
            if cmd.startswith("cd "):
                new_dir = cmd[3:].strip()
                if new_dir == "../..":
                    cwd = cwd.parent.parent
                elif new_dir == "..":
                    cwd = cwd.parent
                elif new_dir.startswith("/"):
                    cwd = Path(new_dir)
                else:
                    cwd = cwd / new_dir
                print(f"    {C.DIM}$ {cmd}{C.NC}")
                continue

            # Handle source commands - skip them (venv activation)
            if cmd.startswith("source "):
                print(f"    {C.DIM}$ {cmd} (skipped){C.NC}")
                continue

            # Handle export commands - set in environment
            if cmd.startswith("export "):
                print(f"    {C.DIM}$ {cmd}{C.NC}")
                # Parse export VAR=value
                var_part = cmd[7:].strip()
                if "=" in var_part:
                    var_name, var_value = var_part.split("=", 1)
                    # Expand ${HOME} and similar
                    var_value = var_value.strip('"').strip("'")
                    var_value = os.path.expandvars(var_value)
                    os.environ[var_name] = var_value
                continue

            # Handle pip install - skip
            if cmd.startswith("pip ") or cmd.startswith("pip3 "):
                print(f"    {C.DIM}$ {cmd} (skipped){C.NC}")
                continue

            # Handle python venv creation - skip
            if "venv" in cmd and "python" in cmd:
                print(f"    {C.DIM}$ {cmd} (skipped){C.NC}")
                continue

            # Run the command
            print(f"    {C.DIM}${C.NC} {C.SKY}{cmd}{C.NC}")

            try:
                result = subprocess.run(
                    cmd,
                    shell=True,
                    cwd=cwd,
                    capture_output=True,
                    text=True,
                    timeout=120,
                    env=os.environ.copy(),
                )

                if result.returncode == 0:
                    print(f"      {C.MINT}✓{C.NC} {C.DIM}exit 0{C.NC}")
                else:
                    print(f"      {C.CORAL}✗{C.NC} {C.DIM}exit {result.returncode}{C.NC}")
                    if result.stderr:
                        # Show first line of error
                        err_line = result.stderr.strip().split("\n")[0][:60]
                        print(f"      {C.DIM}{err_line}{C.NC}")
                    block_passed = False

            except subprocess.TimeoutExpired:
                print(f"      {C.CORAL}✗{C.NC} {C.DIM}timeout{C.NC}")
                block_passed = False
            except Exception as e:
                print(f"      {C.CORAL}✗{C.NC} {C.DIM}{str(e)[:50]}{C.NC}")
                block_passed = False

        if block_passed:
            passed += 1
            results.append((title, True, None))
        else:
            failed += 1
            results.append((title, False, "Command failed"))

        print()

    # Summary
    print(f"  {C.DIM}{'─' * 55}{C.NC}")
    if failed == 0:
        print(f"  {C.MINT}✓ All validation steps passed ({passed}/{passed}){C.NC}")
    else:
        print(f"  {C.CORAL}✗ Validation: {passed} passed, {failed} failed{C.NC}")
    print()

    return passed, failed, results


# ═══════════════════════════════════════════════════════════════════
# DISPLAY
# ═══════════════════════════════════════════════════════════════════


def print_header(project_name: str = ""):
    """Print the Ralph header."""
    display_name = project_name or "Ralph"
    # Pad/truncate to fit the box (11 chars for project name area)
    display_name = display_name[:11].ljust(11)
    print()
    print(f"{C.SKY}  ┌─────────────────────────────────────────────────────────┐{C.NC}")
    print(
        f"{C.SKY}  │{C.NC}     {C.PINK}{display_name}{C.NC} {C.DIM}~ Ralph Loop Runner{C.NC}                    {C.SKY}│{C.NC}"
    )
    print(f"{C.SKY}  └─────────────────────────────────────────────────────────┘{C.NC}")
    print()


def print_task_list(tasks: list, indent: str = "  "):
    """Print list of tasks with status indicators."""
    for task in tasks:
        indicator = "→" if task["ready"] else "⏸"
        print(f"{indent}{indicator} {task['id']}: {task['title']}")


def print_completed_tasks(prd: dict, indent: str = "    "):
    """Print completed tasks."""
    for story in prd.get("stories", []):
        if story.get("status") == "completed":
            # Show verification status for milestones
            if is_milestone_task(story):
                if story.get("verified", False):
                    print(f"{indent}{C.MINT}✓{C.NC} {story['id']}: {story['title']} {C.MINT}[verified]{C.NC}")
                elif story.get("skipped", False):
                    print(f"{indent}{C.PEACH}⊘{C.NC} {story['id']}: {story['title']} {C.PEACH}[skipped]{C.NC}")
                else:
                    print(f"{indent}{C.YELLOW}⚠{C.NC} {story['id']}: {story['title']} {C.YELLOW}[needs verification]{C.NC}")
            else:
                print(f"{indent}✓ {story['id']}: {story['title']}")


# ═══════════════════════════════════════════════════════════════════
# COMMANDS
# ═══════════════════════════════════════════════════════════════════


def get_ralph_implementation_dir() -> Path:
    """Get the directory where ralph's implementation lives."""
    # This script's actual location (resolving symlinks)
    return Path(__file__).resolve().parent


def verify_installation(target_dir: Path, ralph_impl_dir: Path) -> bool:
    """Verify an existing ralph installation and report/fix issues."""
    ralph_dir = target_dir / ".ralph"
    ralph_script = ralph_impl_dir / "ralph"
    issues = []
    fixed = []

    print(f"  {C.BOLD}{C.LAVENDER}Verifying Ralph Installation{C.NC}")
    print()
    print(f"  {C.DIM}Project:{C.NC}   {C.SAGE}{target_dir}{C.NC}")
    print(f"  {C.DIM}Ralph at:{C.NC}  {C.SAGE}{ralph_impl_dir}{C.NC}")
    print()

    # Check symlink
    symlink_path = ralph_dir / "ralph"
    if symlink_path.exists():
        if symlink_path.is_symlink():
            link_target = symlink_path.resolve()
            if link_target == ralph_script:
                print(f"  {C.MINT}✓{C.NC} Symlink correct: .ralph/ralph → {ralph_script}")
            else:
                print(f"  {C.CORAL}✗{C.NC} Symlink points to wrong location: {link_target}")
                issues.append(("symlink_wrong", symlink_path, ralph_script))
        else:
            print(f"  {C.CORAL}✗{C.NC} .ralph/ralph is not a symlink (it's a regular file)")
            issues.append(("symlink_not_link", symlink_path, ralph_script))
    else:
        print(f"  {C.CORAL}✗{C.NC} Missing: .ralph/ralph symlink")
        issues.append(("symlink_missing", symlink_path, ralph_script))

    # Check required directories
    runs_dir = ralph_dir / "runs"
    if runs_dir.exists() and runs_dir.is_dir():
        print(f"  {C.MINT}✓{C.NC} Directory exists: .ralph/runs/")
    else:
        print(f"  {C.CORAL}✗{C.NC} Missing: .ralph/runs/ directory")
        issues.append(("dir_missing", runs_dir))

    # Check required files
    for filename in ("README.md", "CYCLE.md", "NOTES.md"):
        filepath = ralph_dir / filename
        if filepath.exists():
            print(f"  {C.MINT}✓{C.NC} File exists: .ralph/{filename}")
        else:
            print(f"  {C.YELLOW}○{C.NC} Missing: .ralph/{filename}")
            issues.append(("file_missing", filepath, filename))

    print()

    if not issues:
        print(f"  {C.MINT}✓ Installation verified - everything looks good!{C.NC}")
        print()
        return True

    # Offer to fix issues
    print(f"  {C.YELLOW}Found {len(issues)} issue(s). Attempting to fix...{C.NC}")
    print()

    for issue in issues:
        issue_type = issue[0]

        if issue_type == "symlink_missing":
            symlink_path, target = issue[1], issue[2]
            symlink_path.symlink_to(target)
            print(f"  {C.MINT}✓{C.NC} Created symlink: .ralph/ralph")
            fixed.append(issue)

        elif issue_type == "symlink_wrong":
            symlink_path, target = issue[1], issue[2]
            symlink_path.unlink()
            symlink_path.symlink_to(target)
            print(f"  {C.MINT}✓{C.NC} Fixed symlink: .ralph/ralph")
            fixed.append(issue)

        elif issue_type == "symlink_not_link":
            symlink_path, target = issue[1], issue[2]
            # Backup the file first
            backup_path = symlink_path.with_suffix(".backup")
            symlink_path.rename(backup_path)
            symlink_path.symlink_to(target)
            print(f"  {C.MINT}✓{C.NC} Replaced file with symlink (backup: {backup_path.name})")
            fixed.append(issue)

        elif issue_type == "dir_missing":
            dir_path = issue[1]
            dir_path.mkdir(parents=True)
            print(f"  {C.MINT}✓{C.NC} Created directory: {dir_path.relative_to(target_dir)}")
            fixed.append(issue)

        elif issue_type == "file_missing":
            # Don't auto-create content files - just warn
            filepath, filename = issue[1], issue[2]
            print(f"  {C.DIM}○{C.NC} Skipped: .ralph/{filename} (create manually or reinstall)")

    print()

    unfixed = len(issues) - len(fixed)
    if unfixed == 0:
        print(f"  {C.MINT}✓ All issues fixed!{C.NC}")
    else:
        print(f"  {C.YELLOW}○ {unfixed} issue(s) need manual attention{C.NC}")

    print()
    return unfixed == 0


def cmd_install(args, target_dir: Path):
    """Install ralph in a new project directory, or verify existing installation."""
    ralph_impl_dir = get_ralph_implementation_dir()
    ralph_script = ralph_impl_dir / "ralph"
    ralph_dir = target_dir / ".ralph"

    # If already installed, verify the installation
    if ralph_dir.exists():
        return verify_installation(target_dir, ralph_impl_dir)

    print(f"  {C.BOLD}{C.LAVENDER}Installing Ralph{C.NC}")
    print()
    print(f"  {C.DIM}Target:{C.NC}    {C.SAGE}{target_dir}{C.NC}")
    print(f"  {C.DIM}Ralph at:{C.NC}  {C.SAGE}{ralph_impl_dir}{C.NC}")
    print()

    # Create directory structure
    ralph_dir.mkdir(parents=True)
    (ralph_dir / "runs").mkdir()

    # Create symlink to ralph script
    symlink_path = ralph_dir / "ralph"
    symlink_path.symlink_to(ralph_script)
    print(f"  {C.MINT}✓{C.NC} Created symlink: .ralph/ralph")

    # Create README.md
    readme_content = f"""# Ralph - Development Loop Runner

This project uses **Ralph**, a development iteration system for Claude Code.

## Quick Start

```bash
.ralph/ralph run      # Execute PRD tasks
.ralph/ralph info     # Show current status
.ralph/ralph runs     # List all runs
```

## How It Works

Ralph runs Claude Code in fresh sessions to complete tasks from a PRD (Product Requirements Document).

1. **Create a PRD** in `.ralph/runs/run-NNN-description/prd.json`
2. **Run Ralph** with `.ralph/ralph run`
3. **Claude works** on one task per iteration
4. **Ralph commits** changes and moves to next task
5. **Milestones pause** for manual verification

## Directory Structure

```
.ralph/
├── ralph          → Symlink to central implementation
├── README.md      → This file
├── CYCLE.md       → Current development stage
├── NOTES.md       → User constraints & project context
└── runs/          → PRD runs
    └── run-001-*/
        ├── prd.json      → Task definitions
        └── progress.txt  → Execution log
```

## Important: Making Changes to Ralph

**DO NOT modify the ralph script in this repo.**

The `ralph` file in `.ralph/` is a symlink to the central implementation.
To find where Ralph lives, check the symlink:

```bash
ls -la .ralph/ralph
```

If you want to improve or fix Ralph:
1. Follow the symlink to find the implementation repo
2. Make your changes there
3. All projects using Ralph will get the updates

This keeps Ralph consistent across all projects and makes updates easy.

## PRD Format

PRDs are JSON files with this structure:

```json
{{
  "title": "Project Name",
  "status": "active",
  "stories": [
    {{
      "id": "001",
      "title": "Task title",
      "description": "What to do",
      "status": "open",
      "dependencies": []
    }},
    {{
      "id": "M1",
      "title": "Milestone: Review Progress",
      "category": "milestone",
      "status": "open",
      "dependencies": ["001"]
    }}
  ]
}}
```

- Task IDs starting with `M` are milestones (require manual verification)
- Dependencies must be completed before a task becomes available
- Status: `open` → `completed`

## Tips

- Read `NOTES.md` before starting - it contains important constraints
- Check `CYCLE.md` to know what development stage you're in
- Milestones pause execution for human review
- Run `ralph info` to see current progress

---

*Check `.ralph/ralph` symlink to find Ralph's implementation repo*
"""
    (ralph_dir / "README.md").write_text(readme_content)
    print(f"  {C.MINT}✓{C.NC} Created README.md")

    # Create CYCLE.md
    cycle_content = """# Development Cycle

Current stage in the development cycle.

## Stages

```
║ 1. DISCUSS & MAP    → Talk with user, explore problems
║ 2. DESIGN PRD       → Convert discussion into structured tasks
▶ 3. EXECUTE PRD      → Run ralph loop, complete tasks
║ 4. EVALUATE         → Test, review, document learnings
║ 5. NEW CYCLE        → Archive and start fresh
```

---

*Update the arrow (▶) to indicate current stage*
"""
    (ralph_dir / "CYCLE.md").write_text(cycle_content)
    print(f"  {C.MINT}✓{C.NC} Created CYCLE.md")

    # Create NOTES.md
    notes_content = """# User Notes & Directives

**This file contains important context for Claude. Read before each iteration.**

---

## Project Context

*(Describe what this project is and what you're trying to accomplish)*

---

## User Requirements

*(Add specific requirements, constraints, and preferences here)*

---

## Technical Decisions

*(Document important technical decisions and their rationale)*

---

## Constraints (Don't Do These)

*(List things that should NOT be done)*

---

## Learnings & Insights

*(Update as project progresses)*

---

*Last updated: (date)*
"""
    (ralph_dir / "NOTES.md").write_text(notes_content)
    print(f"  {C.MINT}✓{C.NC} Created NOTES.md")

    print()
    print(f"  {C.MINT}✓ Ralph installed successfully!{C.NC}")
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Next steps:{C.NC}")
    print(f"    1. Edit {C.SAGE}.ralph/NOTES.md{C.NC} with project context")
    print(f"    2. Create a PRD in {C.SAGE}.ralph/runs/run-001-description/prd.json{C.NC}")
    print(f"    3. Run {C.SAGE}.ralph/ralph run{C.NC} to start")
    print()

    return True


def apply_prereqs(project_dir: Path, blocks: list) -> tuple:
    """Apply Prerequisites step: cd commands, exports, detect venv.

    Looks for setup commands in:
    1. A step titled "Prerequisites" (explicit)
    2. The first step (step 1) as fallback

    Returns (working_directory, venv_python_path or None).
    """
    cwd = project_dir
    venv_python = None

    def extract_setup_from_block(block):
        """Extract cd, export, source commands from a block."""
        nonlocal cwd, venv_python
        for cmd in block["commands"]:
            cmd = cmd.strip()
            # Handle cd
            if cmd.startswith("cd "):
                new_dir = cmd[3:].strip()
                if new_dir.startswith("/"):
                    cwd = Path(new_dir)
                else:
                    cwd = project_dir / new_dir
            # Handle export
            elif cmd.startswith("export "):
                var_part = cmd[7:].strip()
                if "=" in var_part:
                    var_name, var_value = var_part.split("=", 1)
                    var_value = var_value.strip('"').strip("'")
                    var_value = os.path.expandvars(var_value)
                    os.environ[var_name] = var_value
            # Handle source venv
            elif cmd.startswith("source ") and "venv" in cmd:
                # Will check if venv exists after we know cwd
                pass

    # First, look for explicit Prerequisites step
    found_prereqs = False
    for block in blocks:
        if "prereq" in block["title"].lower():
            extract_setup_from_block(block)
            found_prereqs = True
            break

    # If no Prerequisites, check step 1 for cd/export commands
    if not found_prereqs and blocks:
        extract_setup_from_block(blocks[0])

    # Check for venv in the working directory
    venv_path = cwd / ".venv"
    if venv_path.exists():
        venv_python = str(venv_path / "bin" / "python3")

    return cwd, venv_python


def run_milestone_step(project_dir: Path, step: dict, step_num: int, initial_cwd: Path = None, venv_python: str = None) -> bool:
    """Run a single milestone verification step.

    Shows description, copyable code, then executes it.
    Returns True if step passed.

    Args:
        project_dir: Root project directory
        step: Step dict with 'title' and 'commands'
        step_num: Step number for display
        initial_cwd: Working directory from Prerequisites (if any)
        venv_python: Path to venv python3 from Prerequisites (if any)
    """
    title = step["title"]
    commands = step["commands"]

    print(f"  {C.BOLD}{C.LAVENDER}Step {step_num}: {title}{C.NC}")
    print()

    # Show copyable code block
    print(f"  {C.DIM}┌{'─' * 60}{C.NC}")
    for cmd in commands:
        # For multi-line commands, show each line
        for line in cmd.split("\n"):
            print(f"  {C.DIM}│{C.NC} {C.SKY}{line}{C.NC}")
    print(f"  {C.DIM}└{'─' * 60}{C.NC}")
    print()

    # Ask to run
    try:
        reply = input(f"  {C.YELLOW}Run this step? [Y/n]{C.NC} ").strip().lower()
    except (KeyboardInterrupt, EOFError):
        print()
        return False

    if reply in ("n", "no"):
        print(f"  {C.DIM}Skipped{C.NC}")
        print()
        return True  # Not a failure, just skipped

    print()

    # Track cwd for cd commands - start from prereqs cwd if provided
    cwd = initial_cwd or project_dir
    all_passed = True
    # venv_python is now passed in from apply_prereqs, but can still be set by source command in this step

    for cmd in commands:
        # Handle cd commands
        if cmd.strip().startswith("cd "):
            new_dir = cmd.strip()[3:].strip()
            if new_dir == "../..":
                target = cwd.parent.parent
            elif new_dir == "..":
                target = cwd.parent
            elif new_dir.startswith("/"):
                target = Path(new_dir)
            else:
                target = cwd / new_dir

            # Skip cd if target doesn't exist but we're already in a matching directory
            if not target.exists() and cwd.name == new_dir.rstrip("/").split("/")[-1]:
                print(f"  {C.DIM}$ cd {new_dir} (already there){C.NC}")
                continue

            cwd = target
            print(f"  {C.DIM}$ cd {new_dir}{C.NC}")
            continue

        # Handle source venv - check if venv exists and set venv_python
        if cmd.strip().startswith("source ") and "venv" in cmd:
            # Extract venv path and check if it exists
            venv_path = cwd / ".venv"
            if venv_path.exists():
                venv_python = str(venv_path / "bin" / "python3")
                print(f"  {C.DIM}$ {cmd.split(chr(10))[0][:50]}{C.NC}")
                print(f"    {C.MINT}✓ Using venv: {venv_path}{C.NC}")
            else:
                print(f"  {C.DIM}$ {cmd.split(chr(10))[0][:50]} (venv not found){C.NC}")
            continue

        # Skip pip/venv creation
        if "venv" in cmd and "python" in cmd:
            print(f"  {C.DIM}$ {cmd.split(chr(10))[0][:50]}... (skipped){C.NC}")
            continue
        if cmd.strip().startswith("pip"):
            print(f"  {C.DIM}$ {cmd.split(chr(10))[0][:50]}... (skipped){C.NC}")
            continue

        # Handle export
        if cmd.strip().startswith("export "):
            var_part = cmd.strip()[7:].strip()
            if "=" in var_part:
                var_name, var_value = var_part.split("=", 1)
                var_value = var_value.strip('"').strip("'")
                var_value = os.path.expandvars(var_value)
                os.environ[var_name] = var_value
            print(f"  {C.DIM}$ {cmd.strip()}{C.NC}")
            continue

        # Replace python3 with venv python if venv is active
        actual_cmd = cmd
        if venv_python and (cmd.strip().startswith("python3 ") or cmd.strip().startswith("python ")):
            actual_cmd = cmd.replace("python3 ", f"{venv_python} ", 1).replace("python ", f"{venv_python} ", 1)

        # Show command being run
        first_line = cmd.split("\n")[0]
        if "\n" in cmd:
            print(f"  {C.DIM}${C.NC} {C.SKY}{first_line}...{C.NC} {C.DIM}(multi-line){C.NC}")
        else:
            print(f"  {C.DIM}${C.NC} {C.SKY}{cmd[:70]}{C.NC}")

        # Run the command with real-time output streaming
        try:
            process = subprocess.Popen(
                actual_cmd,
                shell=True,
                cwd=cwd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,  # Merge stderr into stdout
                text=True,
                env=os.environ.copy(),
            )

            # Stream output in real-time with indentation
            output_lines = []
            print(f"  {C.DIM}─────────────────────────────────────────{C.NC}")
            for line in process.stdout:
                line = line.rstrip()
                output_lines.append(line)
                # Color output based on content
                if "error" in line.lower() or "fail" in line.lower():
                    print(f"  {C.CORAL}  {line}{C.NC}")
                elif "success" in line.lower() or "pass" in line.lower() or line.startswith("✓"):
                    print(f"  {C.MINT}  {line}{C.NC}")
                elif line.startswith("[") and "]" in line:  # Log lines
                    print(f"  {C.DIM}  {line}{C.NC}")
                else:
                    print(f"    {line}")

            process.wait(timeout=300)
            print(f"  {C.DIM}─────────────────────────────────────────{C.NC}")

            if process.returncode == 0:
                print(f"  {C.MINT}✓ Success{C.NC}")
            else:
                print(f"  {C.CORAL}✗ Failed (exit {process.returncode}){C.NC}")
                all_passed = False

        except subprocess.TimeoutExpired:
            process.kill()
            print(f"  {C.CORAL}✗ Timeout (5 min){C.NC}")
            all_passed = False
        except Exception as e:
            print(f"  {C.CORAL}✗ Error: {e}{C.NC}")
            all_passed = False

        print()

    return all_passed


def cmd_milestone(args, project_dir: Path, prd_file: Path, prd: dict, milestone_id: str | None = None, step_num: str | None = None):
    """List milestones, show details, or run a specific step."""
    milestones = [s for s in prd.get("stories", []) if is_milestone_task(s)]

    if not milestones:
        print(f"  {C.DIM}No milestones found in PRD{C.NC}")
        print()
        return

    if milestone_id:
        # Show details for specific milestone (case-insensitive match)
        milestone = next(
            (m for m in milestones if m["id"].lower() == milestone_id.lower()), None
        )
        if not milestone:
            print(f"  {C.CORAL}Milestone '{milestone_id}' not found{C.NC}")
            print()
            print(f"  {C.DIM}Available milestones:{C.NC}")
            for m in milestones:
                print(f"    {m['id']}: {m['title']}")
            print()
            return

        # Handle --skip flag (use actual ID from milestone for correct case)
        actual_id = milestone["id"]
        if args.skip:
            mark_milestone_skipped(prd_file, prd, actual_id)
            print(f"  {C.MINT}✓ Milestone {actual_id} marked as skipped{C.NC}")
            print(f"  {C.DIM}Ralph will no longer pause for this milestone.{C.NC}")
            print()
            return

        # Get verification steps
        blocks = extract_code_blocks(milestone.get("description", ""))

        # Handle step execution: ralph milestone M1 <step>
        if step_num:
            try:
                step_idx = int(step_num) - 1  # 1-indexed for user
                if step_idx < 0 or step_idx >= len(blocks):
                    print(f"  {C.CORAL}Step {step_num} not found{C.NC}")
                    print(f"  {C.DIM}Available steps: 1-{len(blocks)}{C.NC}")
                    print()
                    return
                step = blocks[step_idx]
                # Apply Prerequisites (cd, exports, venv)
                initial_cwd, venv_python = apply_prereqs(project_dir, blocks)
                if initial_cwd != project_dir:
                    print(f"  {C.DIM}Working directory: {initial_cwd}{C.NC}")
                if venv_python:
                    print(f"  {C.DIM}Python: {venv_python}{C.NC}")
                if initial_cwd != project_dir or venv_python:
                    print()
                run_milestone_step(project_dir, step, int(step_num), initial_cwd, venv_python)
                return
            except ValueError:
                print(f"  {C.CORAL}Invalid step number: {step_num}{C.NC}")
                print()
                return

        # Show milestone details
        status = milestone.get("status", "open")
        verified = milestone.get("verified", False)
        skipped = milestone.get("skipped", False)

        print(f"  {C.BOLD}{C.LAVENDER}Milestone: {milestone['id']}{C.NC}")
        print()
        print(f"  {C.SAGE}{milestone['title']}{C.NC}")
        print()

        # Status
        if status == "completed":
            if verified:
                print(f"  {C.DIM}Status:{C.NC}  {C.MINT}✓ Completed & Verified{C.NC}")
            elif skipped:
                print(f"  {C.DIM}Status:{C.NC}  {C.PEACH}⊘ Completed (skipped){C.NC}")
            else:
                print(f"  {C.DIM}Status:{C.NC}  {C.YELLOW}⚠ Completed (needs verification){C.NC}")
        else:
            print(f"  {C.DIM}Status:{C.NC}  {C.DIM}○ Open{C.NC}")

        # Dependencies
        deps = milestone.get("dependencies", [])
        if deps:
            completed_ids = get_completed_task_ids(prd)
            print(f"  {C.DIM}Depends on:{C.NC}")
            for dep_id in deps:
                dep_done = dep_id in completed_ids
                indicator = f"{C.MINT}✓{C.NC}" if dep_done else f"{C.DIM}○{C.NC}"
                # Find dep title
                dep_task = next((s for s in prd.get("stories", []) if s["id"] == dep_id), None)
                dep_title = dep_task["title"] if dep_task else "(unknown)"
                print(f"    {indicator} {dep_id}: {dep_title}")
        print()

        # Verification steps
        if blocks:
            print(f"  {C.BOLD}{C.LAVENDER}Verification Steps:{C.NC}")
            print()
            for i, block in enumerate(blocks, 1):
                print(f"    {C.PINK}{i}{C.NC}  {C.SAGE}{block['title']}{C.NC}")
                print(f"       {C.DIM}{len(block['commands'])} command(s){C.NC}")
            print()
            print(f"  {C.DIM}Run a step:{C.NC} {C.SAGE}ralph milestone {actual_id} <step>{C.NC}")
            print(f"  {C.DIM}Example:{C.NC}    {C.SAGE}ralph milestone {actual_id} 1{C.NC}")
            print()
            return  # Don't show the full description - steps are cleaner

        # Description (fallback if no steps found)
        desc = milestone.get("description", "")
        if desc:
            print(f"  {C.BOLD}{C.LAVENDER}Description:{C.NC}")
            print()
            print(f"  {C.DIM}{'─' * 55}{C.NC}")
            print()
            # Handle both \\n (JSON escaped) and actual newlines
            desc_lines = desc.replace("\\n", "\n").split("\n")
            in_code_block = False
            for line in desc_lines:
                stripped = line.strip()
                # Code block markers
                if stripped.startswith("```"):
                    in_code_block = not in_code_block
                    if in_code_block:
                        lang = stripped[3:] or "code"
                        print(f"    {C.DIM}┌─ {lang} ─{'─' * (40 - len(lang))}{C.NC}")
                    else:
                        print(f"    {C.DIM}└{'─' * 45}{C.NC}")
                    continue
                # Inside code block - show as commands
                if in_code_block:
                    if stripped.startswith("#"):
                        print(f"    {C.DIM}│{C.NC} {C.DIM}{stripped}{C.NC}")
                    else:
                        print(f"    {C.DIM}│{C.NC} {C.SKY}{stripped}{C.NC}")
                    continue
                # Markdown headers (## Header)
                if stripped.startswith("## "):
                    print()
                    print(f"    {C.YELLOW}{C.BOLD}{stripped[3:]}{C.NC}")
                    continue
                if stripped.startswith("# "):
                    print()
                    print(f"    {C.CORAL}{C.BOLD}{stripped[2:]}{C.NC}")
                    continue
                # Bullet points with checkboxes - [ ] or [x]
                if stripped.startswith("- [ ]") or stripped.startswith("- [x]"):
                    checked = "[x]" in stripped[:6]
                    content = stripped[6:].strip()
                    check = f"{C.MINT}✓{C.NC}" if checked else f"{C.DIM}○{C.NC}"
                    print(f"      {check} {C.SAGE}{content}{C.NC}")
                    continue
                # Regular bullet points
                if stripped.startswith("- ") or stripped.startswith("* "):
                    content = stripped[2:]
                    print(f"    {C.MINT}•{C.NC} {C.SAGE}{content}{C.NC}")
                    continue
                # Numbered items
                if stripped and stripped[0].isdigit() and ". " in stripped[:4]:
                    num_end = stripped.index(". ")
                    num = stripped[:num_end]
                    content = stripped[num_end + 2:]
                    print(f"    {C.PINK}{num}.{C.NC} {C.SAGE}{content}{C.NC}")
                    continue
                # Empty lines
                if not stripped:
                    print()
                    continue
                # Regular text
                print(f"    {C.SAGE}{stripped}{C.NC}")
            print()
            print(f"  {C.DIM}{'─' * 55}{C.NC}")
            print()

        # Manual verification commands
        print(f"  {C.BOLD}{C.LAVENDER}Manual Verification Commands:{C.NC}")
        print()
        print(f"  {C.DIM}View this milestone in PRD:{C.NC}")
        print(f"    {C.SAGE}cat {prd_file.relative_to(project_dir)} | jq '.stories[] | select(.id==\"{milestone_id}\")'{C.NC}")
        print()
        print(f"  {C.DIM}View progress log:{C.NC}")
        run_dir = get_run_dir(prd_file)
        if run_dir:
            progress_file = run_dir / "progress.txt"
            print(f"    {C.SAGE}cat {progress_file.relative_to(project_dir)}{C.NC}")
        else:
            print(f"    {C.SAGE}cat .ralph/progress.txt{C.NC}")
        print()
        print(f"  {C.DIM}View git log for recent changes:{C.NC}")
        print(f"    {C.SAGE}git log --oneline -20{C.NC}")
        print()
        print(f"  {C.DIM}Check file changes:{C.NC}")
        print(f"    {C.SAGE}git diff HEAD~5 --stat{C.NC}")
        print()

        if status == "completed" and not verified:
            print(f"  {C.BOLD}{C.YELLOW}To mark as verified:{C.NC}")
            print(f"    {C.SAGE}ralph run{C.NC}  {C.DIM}(will prompt for verification){C.NC}")
            print()

    else:
        # List all milestones
        print(f"  {C.BOLD}{C.LAVENDER}Milestones{C.NC}")
        print()

        completed_ids = get_completed_task_ids(prd)

        for milestone in milestones:
            status = milestone.get("status", "open")
            verified = milestone.get("verified", False)
            skipped = milestone.get("skipped", False)
            deps = milestone.get("dependencies", [])
            deps_met = all(d in completed_ids for d in deps)

            # Determine indicator
            if status == "completed":
                if verified:
                    indicator = f"{C.MINT}✓{C.NC}"
                    status_text = f"{C.MINT}verified{C.NC}"
                elif skipped:
                    indicator = f"{C.PEACH}⊘{C.NC}"
                    status_text = f"{C.PEACH}skipped{C.NC}"
                else:
                    indicator = f"{C.YELLOW}⚠{C.NC}"
                    status_text = f"{C.YELLOW}needs verification{C.NC}"
            else:
                if deps_met:
                    indicator = f"{C.SKY}→{C.NC}"
                    status_text = f"{C.DIM}ready{C.NC}"
                else:
                    indicator = f"{C.DIM}⏸{C.NC}"
                    status_text = f"{C.DIM}blocked{C.NC}"

            print(f"  {indicator} {C.PINK}{milestone['id']}{C.NC}: {milestone['title']}")
            print(f"      {status_text}")
            print()

        print(f"  {C.DIM}View details:{C.NC} {C.SAGE}ralph milestone <id>{C.NC}")
        print(f"  {C.DIM}Skip milestone:{C.NC} {C.SAGE}ralph milestone <id> --skip{C.NC}")
        print()


def cmd_runs(args, project_dir: Path):
    """List all runs."""
    runs_dir = project_dir / ".ralph" / "runs"

    if not runs_dir.exists() or not any(runs_dir.iterdir()):
        print(f"  {C.DIM}No runs found{C.NC}")
        print()
        return

    print(f"  {C.BOLD}{C.LAVENDER}All Runs{C.NC}")
    print()

    run_dirs = sorted(
        [d for d in runs_dir.iterdir() if d.is_dir() and d.name.startswith("run-")],
        key=lambda d: d.name,
    )

    for i, run_dir in enumerate(run_dirs, 1):
        prd_file = run_dir / "prd.json"
        if prd_file.exists():
            try:
                run_prd = load_prd(prd_file)
                status = run_prd.get("status", "unknown")
                title = run_prd.get("title", "Untitled")
                counts = count_tasks_by_status(run_prd)

                if status == "active":
                    indicator = f"{C.MINT}● active{C.NC}"
                elif status == "completed":
                    indicator = f"{C.SAGE}✓ done{C.NC}"
                else:
                    indicator = f"{C.DIM}○ {status}{C.NC}"

                print(f"  {C.PINK}{i}{C.NC}  {C.SKY}{run_dir.name}{C.NC}  {indicator}")
                print(f"       {C.SAGE}{title}{C.NC}")
                print(
                    f"       {C.DIM}{counts['completed']}/{counts['total']} tasks completed{C.NC}"
                )
                print()
            except Exception:
                print(
                    f"  {C.PINK}{i}{C.NC}  {C.SKY}{run_dir.name}{C.NC}  {C.CORAL}(error reading PRD){C.NC}"
                )
                print()

    print(
        f"  {C.DIM}View details:{C.NC} {C.SAGE}ralph show <index|name>{C.NC}"
    )
    print()


def cmd_info(args, project_dir: Path, prd_file: Path, prd: dict):
    """Show current cycle status and PRD details."""
    counts = count_tasks_by_status(prd)

    print(f"  {C.BOLD}{C.LAVENDER}Current Cycle{C.NC}")
    print()

    stage = get_cycle_stage(project_dir)
    print(f"  {C.DIM}Stage{C.NC}         {C.MINT}{stage}{C.NC}")
    print(f"  {C.DIM}PRD{C.NC}           {C.SAGE}{get_prd_title(prd)}{C.NC}")
    print(
        f"  {C.DIM}File{C.NC}          {C.SAGE}{prd_file.relative_to(project_dir)}{C.NC}"
    )
    print(
        f"  {C.DIM}Progress{C.NC}      {C.SAGE}{counts['completed']}{C.NC}{C.DIM}/{C.NC}{C.SAGE}{counts['total']}{C.NC} {C.DIM}tasks completed{C.NC}"
    )
    print()

    print(f"  {C.BOLD}{C.LAVENDER}Tasks{C.NC}")
    print()

    if counts["completed"] > 0:
        print(f"  {C.DIM}Completed:{C.NC}")
        print_completed_tasks(prd)
        print()

    open_tasks = get_open_tasks(prd)
    if open_tasks:
        ready_count = sum(1 for t in open_tasks if t["ready"])
        print(
            f"  {C.DIM}Open:{C.NC} {C.DIM}({ready_count} ready, {len(open_tasks) - ready_count} blocked){C.NC}"
        )
        for task in open_tasks:
            indicator = "→" if task["ready"] else "⏸"
            print(f"    {indicator} {task['id']}: {task['title']}")
        print()

    notes_file = project_dir / ".ralph" / "NOTES.md"
    if notes_file.exists():
        print(f"  {C.DIM}See notes:{C.NC} {C.SAGE}cat .ralph/NOTES.md{C.NC}")
        print()


def cmd_run(args, project_dir: Path, prd_file: Path, prd: dict):
    """Run the Ralph loop."""
    counts = count_tasks_by_status(prd)
    open_tasks = get_open_tasks(prd)
    next_task = get_next_task(prd)

    print(f"  {C.BOLD}{C.LAVENDER}PRD:{C.NC} {C.SAGE}{get_prd_title(prd)}{C.NC}")
    print(f"  {C.DIM}File:{C.NC} {C.SAGE}{prd_file.relative_to(project_dir)}{C.NC}")
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Configuration:{C.NC}")
    print(f"  {C.DIM}Project{C.NC}       {C.SAGE}{project_dir}{C.NC}")
    print(f"  {C.DIM}Max iters{C.NC}     {C.SAGE}{args.max_iterations}{C.NC}")
    print(f"  {C.DIM}Tasks open{C.NC}    {C.SAGE}{counts['open']}{C.NC}")
    print()

    if counts["open"] == 0:
        print(f"  {C.MINT}✓ All tasks already complete!{C.NC}")
        print()
        return

    ready_tasks = [t for t in open_tasks if t["ready"]]
    print(
        f"  {C.BOLD}{C.LAVENDER}Ready Tasks:{C.NC} {C.DIM}({len(ready_tasks)} ready to execute){C.NC}"
    )
    for task in ready_tasks[:5]:
        print(f"    → {task['id']}: {task['title']}")
    if len(ready_tasks) > 5:
        print(f"    {C.DIM}... and {len(ready_tasks) - 5} more{C.NC}")
    print()

    if next_task:
        print(f"  {C.BOLD}{C.YELLOW}First task to execute:{C.NC}")
        print(f"  {C.MINT}▸ {next_task['id']}{C.NC} {C.SAGE}{next_task['title']}{C.NC}")
        print()
    else:
        print(f"  {C.CORAL}✗ No tasks available (check dependencies){C.NC}")
        print()
        return

    # Check for unverified milestones BEFORE asking to proceed (unless skipping)
    if not args.skip_milestones:
        unverified = get_unverified_milestone(prd)
    else:
        unverified = None
        print(f"  {C.DIM}(Skipping milestone verification){C.NC}")
        print()

    if unverified:
        print(
            f"  {C.SKY}─────────────────────────────────────────────────────────{C.NC}"
        )
        print()
        print(f"  {C.YELLOW}{C.BOLD}🛑 UNVERIFIED MILESTONE: {unverified['id']}{C.NC}")
        print(f"  {C.SAGE}{unverified['title']}{C.NC}")
        print()
        print(f"  {C.DIM}This milestone needs verification before continuing.{C.NC}")
        print(f"  {C.DIM}For full details:{C.NC} {C.SAGE}ralph milestone {unverified['id']}{C.NC}")
        print()
        try:
            reply = input(
                f"  {C.YELLOW}Mark as verified and continue? [y/N]{C.NC} "
            ).strip().lower()
        except (KeyboardInterrupt, EOFError):
            print()
            print()
            print(f"  {C.PEACH}Cancelled.{C.NC}")
            print()
            return

        if reply not in ("y", "yes"):
            print()
            print(f"  {C.PEACH}Run 'ralph milestone {unverified['id']}' to review.{C.NC}")
            print()
            return

        # Mark milestone as verified
        mark_milestone_verified(prd_file, prd, unverified["id"])
        print()
        print(f"  {C.MINT}✓ Milestone {unverified['id']} marked as verified{C.NC}")
        print()

        # Check if there are more unverified milestones
        prd = load_prd(prd_file)
        next_unverified = get_unverified_milestone(prd)
        if next_unverified:
            print(
                f"  {C.PEACH}Note: There are more unverified milestones. Run again to verify.{C.NC}"
            )
            print()
            return

    # Now ask to proceed (after milestone check)
    if not args.yes:
        print(
            f"  {C.SKY}─────────────────────────────────────────────────────────{C.NC}"
        )
        print()
        print(f"  {C.YELLOW}Ready to start Ralph loop.{C.NC}")
        print(
            f"  {C.DIM}This will run Claude Code up to {args.max_iterations} times.{C.NC}"
        )
        print()

        try:
            reply = input("  Proceed? [y/N] ").strip().lower()
        except (KeyboardInterrupt, EOFError):
            print()
            print()
            print(f"  {C.PEACH}Cancelled.{C.NC}")
            print()
            return

        print()

        if reply not in ("y", "yes"):
            print(f"  {C.PEACH}Cancelled.{C.NC}")
            print()
            return

    # Setup
    run_dir = get_run_dir(prd_file)
    if run_dir:
        progress_file = run_dir / "progress.txt"
    else:
        progress_file = project_dir / ".ralph" / "progress.txt"
    notes_file = project_dir / ".ralph" / "NOTES.md"

    # Commit any uncommitted changes
    if git_has_changes(project_dir):
        print(f"  {C.PEACH}Found uncommitted changes from previous run{C.NC}")
        git_commit(
            project_dir,
            "[ralph] Recover uncommitted changes from previous run\n\n"
            "Co-Authored-By: Claude <noreply@anthropic.com>",
        )
        print(f"  {C.MINT}✓ Previous changes committed{C.NC}")
        print()

    # Main loop
    for i in range(1, args.max_iterations + 1):
        prd = load_prd(prd_file)
        counts = count_tasks_by_status(prd)
        next_task = get_next_task(prd)

        print(
            f"  {C.SKY}─────────────────────────────────────────────────────────{C.NC}"
        )
        print()
        print(
            f"  {C.LAVENDER}Iteration {C.PINK}{i}{C.LAVENDER} of {C.PINK}{args.max_iterations}{C.NC}    {C.DIM}remaining: {counts['open']} tasks{C.NC}"
        )

        if counts["open"] == 0:
            print(f"  {C.MINT}✓ All tasks complete{C.NC}")
            print()
            break

        if not next_task:
            print(f"  {C.CORAL}✗ No available tasks (check dependencies){C.NC}")
            print()
            break

        print(f"  {C.MINT}▸ {next_task['id']}{C.NC} {C.SAGE}{next_task['title']}{C.NC}")
        print()

        start_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        commit_before = git_rev_parse(project_dir)

        prd_title = get_prd_title(prd)
        prompt = f"""You are working on a development project managed by Ralph.

## Project: {project_dir.name}
## PRD: {prd_title}

## Instructions

1. Read the PRD file: {prd_file}
2. Read progress file: {progress_file}
3. Read notes file: {notes_file} (important user constraints and project context!)
4. Find the FIRST task with status "open" whose dependencies are all "completed"
5. Work on that ONE task completely
6. When done:
   - Update the PRD: change the task's status from "open" to "completed"
   - Append to progress.txt what you did, including:
     - Task ID and title
     - What was accomplished
     - Any files created/modified
     - Any issues encountered
   - Make sure all your work is saved to files

## Important Rules

- Complete ONE task per iteration, then stop
- Read NOTES.md for user constraints and project context
- Create all necessary directories and files
- Write working, tested code
- Update both the PRD AND progress.txt before finishing
- If a task cannot be completed, document why in progress.txt and move on
- MILESTONE tasks (IDs starting with M): These are verification checkpoints.
  Mark them complete after documenting in progress.txt what was built and
  noting that manual verification is recommended.

Start by reading the PRD, progress, and notes files, then work on the next available task.
"""

        print(f"  {C.DIM}Claude is working on task {next_task['id']}...{C.NC}")

        subprocess.run(
            ["claude", "--print", "--dangerously-skip-permissions", str(project_dir)],
            input=prompt,
            capture_output=True,
            text=True,
        )

        end_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"  {C.DIM}Completed at {end_time}{C.NC}")
        print()

        commit_after = git_rev_parse(project_dir)

        if commit_before != commit_after and commit_before != "none":
            commits_made = git_commit_count(project_dir, commit_before, commit_after)
            print(f"  {C.MINT}✓ Claude made {commits_made} commit(s){C.NC}")

        if git_has_changes(project_dir):
            git_commit(
                project_dir,
                f"[ralph] Iteration {i}: {next_task['title']}\n\n"
                f"Task: {next_task['id']}\n"
                f"Time: {start_time} - {end_time}\n\n"
                "Co-Authored-By: Claude <noreply@anthropic.com>",
            )
            print(f"  {C.MINT}✓ Additional changes committed{C.NC}")
        elif commit_before == commit_after:
            print(f"  {C.PEACH}○ No changes{C.NC}")

        print()

        # Check if we just completed a milestone - pause for verification
        prd = load_prd(prd_file)
        task_now = next((s for s in prd.get("stories", []) if s["id"] == next_task["id"]), None)
        if task_now and task_now.get("status") == "completed" and is_milestone_task(next_task):
            print(
                f"  {C.SKY}═══════════════════════════════════════════════════════════{C.NC}"
            )
            print()
            print(f"  {C.YELLOW}{C.BOLD}🛑 MILESTONE REACHED: {next_task['id']}{C.NC}")
            print(f"  {C.SAGE}{next_task['title']}{C.NC}")
            print()
            print(f"  {C.DIM}Ralph has paused for manual verification.{C.NC}")
            print()
            print(f"  {C.MINT}Run verification steps:{C.NC}")
            print(f"    {C.SAGE}ralph milestone {next_task['id']}{C.NC}       {C.DIM}# See all steps{C.NC}")
            print(f"    {C.SAGE}ralph milestone {next_task['id']} 1{C.NC}     {C.DIM}# Run step 1{C.NC}")
            print()
            print(f"  {C.DIM}When verified, run:{C.NC} {C.SAGE}ralph run{C.NC}")
            print()
            print(
                f"  {C.SKY}═══════════════════════════════════════════════════════════{C.NC}"
            )
            print()
            return

        time.sleep(1)

    prd = load_prd(prd_file)
    counts = count_tasks_by_status(prd)

    print(f"  {C.SKY}─────────────────────────────────────────────────────────{C.NC}")
    print()
    print(f"  {C.LAVENDER}Loop complete{C.NC}")
    print(
        f"  {C.DIM}Iterations:{C.NC} {C.SAGE}{i}{C.NC}    {C.DIM}Remaining:{C.NC} {C.SAGE}{counts['open']}{C.NC}"
    )
    print()


# ═══════════════════════════════════════════════════════════════════
# MAIN
# ═══════════════════════════════════════════════════════════════════


def print_usage():
    """Print colorful usage information."""
    project_dir = get_project_dir()
    project_name = project_dir.name
    has_ralph = (project_dir / ".ralph").is_dir()

    print()
    print(f"{C.SKY}  ┌─────────────────────────────────────────────────────────┐{C.NC}")
    print(
        f"{C.SKY}  │{C.NC}     {C.PINK}Ralph{C.NC}       {C.DIM}~ Development Loop Runner{C.NC}              {C.SKY}│{C.NC}"
    )
    print(f"{C.SKY}  └─────────────────────────────────────────────────────────┘{C.NC}")
    print()
    if has_ralph:
        print(f"  {C.BOLD}{C.LAVENDER}Project:{C.NC} {C.MINT}{project_name}{C.NC}")
        print(f"  {C.DIM}Path:{C.NC}    {C.SAGE}{project_dir}{C.NC}")
        print()
    else:
        print(f"  {C.CORAL}No .ralph/ directory found in current path{C.NC}")
        print(f"  {C.DIM}CWD: {project_dir}{C.NC}")
        print()
    print(
        f"  {C.BOLD}{C.LAVENDER}Usage:{C.NC} ralph {C.DIM}[command] [options]{C.NC}"
    )
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Commands:{C.NC}")
    print(
        f"    {C.MINT}run{C.NC}             {C.DIM}Run the iteration loop (execute PRD tasks){C.NC}"
    )
    print(
        f"    {C.MINT}info{C.NC}            {C.DIM}Show current cycle status and PRD details{C.NC}"
    )
    print(f"    {C.MINT}runs{C.NC}            {C.DIM}List all runs{C.NC}")
    print(
        f"    {C.MINT}milestone{C.NC}       {C.DIM}List milestones, show steps, or run a step{C.NC}"
    )
    print(
        f"    {C.MINT}install{C.NC}         {C.DIM}Install ralph in current directory{C.NC}"
    )
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Options:{C.NC}")
    print(
        f"    {C.MINT}-y, --yes{C.NC}       {C.DIM}Skip confirmation prompt (for run){C.NC}"
    )
    print(
        f"    {C.MINT}-s{C.NC}              {C.DIM}Skip all milestone verifications (for run){C.NC}"
    )
    print(
        f"    {C.MINT}--skip{C.NC}          {C.DIM}Mark milestone as skipped (for milestone <id>){C.NC}"
    )
    print(
        f"    {C.MINT}-n, --max{C.NC} N     {C.DIM}Max iterations (default: 20){C.NC}"
    )
    print(f"    {C.MINT}-h, --help{C.NC}      {C.DIM}Show this help{C.NC}")
    print()
    print(f"  {C.BOLD}{C.LAVENDER}Examples:{C.NC}")
    print(f"    {C.SAGE}ralph{C.NC}              {C.DIM}Show this help{C.NC}")
    print(
        f"    {C.SAGE}ralph run{C.NC}          {C.DIM}Run the iteration loop{C.NC}"
    )
    print(
        f"    {C.SAGE}ralph run -y{C.NC}       {C.DIM}Run without confirmation{C.NC}"
    )
    print(
        f"    {C.SAGE}ralph run -n 10{C.NC}    {C.DIM}Run up to 10 iterations{C.NC}"
    )
    print(
        f"    {C.SAGE}ralph info{C.NC}         {C.DIM}Show current status{C.NC}"
    )
    print(f"    {C.SAGE}ralph runs{C.NC}         {C.DIM}List all runs{C.NC}")
    print(f"    {C.SAGE}ralph milestone{C.NC}    {C.DIM}List all milestones{C.NC}")
    print(f"    {C.SAGE}ralph milestone M1{C.NC} {C.DIM}Show verification steps for M1{C.NC}")
    print(f"    {C.SAGE}ralph milestone M1 1{C.NC}  {C.DIM}Run step 1 of milestone M1{C.NC}")
    print(
        f"    {C.SAGE}ralph milestone M1 --skip{C.NC}  {C.DIM}Skip milestone M1{C.NC}"
    )
    print(f"    {C.SAGE}ralph run -s{C.NC}       {C.DIM}Run without milestone pauses{C.NC}")
    print(f"    {C.SAGE}ralph install{C.NC}      {C.DIM}Install ralph in current dir{C.NC}")
    print()


def main():
    if len(sys.argv) == 1 or sys.argv[1] in ("-h", "--help"):
        print_usage()
        sys.exit(0)

    parser = argparse.ArgumentParser(
        description="metrics-dsl Ralph Loop Runner",
        add_help=False,
    )

    parser.add_argument("command", nargs="?", default=None)
    parser.add_argument("subarg", nargs="?", default=None)  # For milestone <id>
    parser.add_argument("subarg2", nargs="?", default=None)  # For milestone <id> <step>
    parser.add_argument("-y", "--yes", action="store_true")
    parser.add_argument("-s", "--skip-milestones", action="store_true", dest="skip_milestones")
    parser.add_argument("--skip", action="store_true")  # For milestone <id> --skip
    parser.add_argument("-n", "--max", type=int, default=20, dest="max_iterations")
    parser.add_argument("-h", "--help", action="store_true")

    args = parser.parse_args()

    if args.help:
        print_usage()
        sys.exit(0)

    project_dir = get_project_dir()
    project_name = project_dir.name
    prd_file = find_prd_file(project_dir)

    print_header(project_name)

    command = args.command

    if command == "install":
        # Install uses CWD, not detected project_dir (which requires .ralph/)
        target_dir = Path.cwd()
        print_header("Install")
        cmd_install(args, target_dir)
    elif command == "runs":
        cmd_runs(args, project_dir)
    elif command in ("run", "info", "milestone"):
        if not prd_file:
            print(f"  {C.CORAL}Error: No PRD file found{C.NC}")
            print(f"  {C.DIM}Looked for: .ralph/runs/run-*/prd.json (active){C.NC}")
            print()
            sys.exit(1)
        prd = load_prd(prd_file)
        if command == "run":
            cmd_run(args, project_dir, prd_file, prd)
        elif command == "milestone":
            cmd_milestone(args, project_dir, prd_file, prd, args.subarg, args.subarg2)
        else:
            cmd_info(args, project_dir, prd_file, prd)
    else:
        print_usage()
        sys.exit(0)


if __name__ == "__main__":
    main()
